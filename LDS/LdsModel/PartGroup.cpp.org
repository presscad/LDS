#include "stdafx.h"
#include "stdio.h"
#include "Tower.h"
#include ".\spherepartgroup.h"
#include "LogFile.h"
#include "SortFunc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif
#if !defined(__TSA_)&&!defined(__TSA_FILE_)

CPartGroupLocatePoint::CPartGroupLocatePoint()
{
	m_hPart=0;
	m_iOrderType=0;
	m_bDimSpace=true;
	m_fStartOffset=m_fEndOffset=m_fLenPosToDatumPart=m_fVertPosToDatumPart=0;
}
void CPartGroupLocatePoint::FromBuffer(CBuffer &buffer,long version/*=0*/,long doc_type/*=0*/)
{
	buffer.ReadPoint(m_xLocalCoordPos);
	buffer.ReadInteger(&m_hPart);
	buffer.ReadInteger(&m_iOrderType);
	buffer.ReadBoolean(&m_bDimSpace);
	buffer.ReadDouble(&m_fStartOffset);
	buffer.ReadDouble(&m_fEndOffset);
}
void CPartGroupLocatePoint::ToBuffer(CBuffer &buffer,long version/*=0*/,long doc_type/*=0*/)
{
	buffer.WritePoint(m_xLocalCoordPos);
	buffer.WriteInteger(m_hPart);
	buffer.WriteInteger(m_iOrderType);
	buffer.WriteBoolean(m_bDimSpace);
	buffer.WriteDouble(m_fStartOffset);
	buffer.WriteDouble(m_fEndOffset);
}

void CPartGroupLocatePoint::ToXmlFile(FILE* fp,DWORD schema)
{
	char sText[500]="";
	fprintf(fp,"<标定点信息>\n");
	fprintf(fp,"<标定点坐标位置 LocalCoordPos=\"(%.3f,%.3f,%.3f)\"/>\n",m_xLocalCoordPos.x,m_xLocalCoordPos.y,m_xLocalCoordPos.z);
	fprintf(fp,"<基准构件 handle=\"0x%x\"/>\n",m_hPart);
	fprintf(fp,"<标定点级别 OrderType=\"%d\"/>\n",m_iOrderType);
	if(m_bDimSpace)
		strcpy(sText,"true");
	else 
		strcpy(sText,"false");
	fprintf(fp,"<是否为绝对尺寸标注点 bDimSpace=\"%s\"/>\n",sText);
	sprintf(sText,"%f",m_fStartOffset);
	SimplifiedNumString(sText);
	fprintf(fp,"<标定点始端偏移量 StartOffset=\"%s\"/>\n",sText);
	sprintf(sText,"%f",m_fEndOffset);
	SimplifiedNumString(sText);
	fprintf(fp,"<标定点终端偏移量 EndOffset=\"%s\"/>\n",sText);
	fprintf(fp,"</标定点信息>\n");
}
CCheckLineDimension::CCheckLineDimension()
{
	m_bBeforeWeld=m_bSpecStartLocatePart=m_bSpecEndLocatePart=false;
	m_hStartPart=m_hEndPart=0;
}
void CCheckLineDimension::FromBuffer(CBuffer &buffer,long version/*=0*/,long doc_type/*=0*/)
{
	buffer.ReadBoolean(&m_bSpecStartLocatePart);
	buffer.ReadBoolean(&m_bSpecEndLocatePart);
	buffer.ReadInteger(&m_hStartPart);
	buffer.ReadInteger(&m_hEndPart);
	buffer.ReadPoint(m_xStartLocalCoordPos);
	buffer.ReadPoint(m_xEndLocalCoordPos);
	buffer.ReadBoolean(&m_bBeforeWeld);
}
void CCheckLineDimension::ToBuffer(CBuffer &buffer,long version/*=0*/,long doc_type/*=0*/)
{
	buffer.WriteBoolean(m_bSpecStartLocatePart);
	buffer.WriteBoolean(m_bSpecEndLocatePart);
	buffer.WriteInteger(m_hStartPart);
	buffer.WriteInteger(m_hEndPart);
	buffer.WritePoint(m_xStartLocalCoordPos);
	buffer.WritePoint(m_xEndLocalCoordPos);
	buffer.WriteBoolean(m_bBeforeWeld);
}

void CCheckLineDimension::ToXmlFile(FILE* fp,DWORD schema)
{
	char sText[500]="";
	fprintf(fp,"<信息>\n");
	if(m_bSpecStartLocatePart)
		strcpy(sText,"true");
	else 
		strcpy(sText,"false");
	fprintf(fp,"<是否指定始端定位构件 bSpecStartLocatePart=\"%s\"/>\n",sText);
	if(m_bSpecEndLocatePart)
		strcpy(sText,"true");
	else
		strcpy(sText,"false");
	fprintf(fp,"<是否指定终端定位杆件 bSpecEndLocatePart=\"%s\"/>\n",sText);
	fprintf(fp,"<始端定位杆件 hStartPart=\"0x%x\"/>\n",m_hStartPart);
	fprintf(fp,"<终端定位杆件 hEndPart=\"0x%x\"/>\n",m_hEndPart);
	fprintf(fp,"<起始坐标 StartLocalCoordPos=\"(%.3f,%.3f,%.3f)\"/>\n",m_xStartLocalCoordPos.x,m_xStartLocalCoordPos.y,m_xStartLocalCoordPos.z);
	fprintf(fp,"<终止坐标 EndLocalCoorPos=\"(%.3f,%.3f,%.3f)\"/>\n",m_xEndLocalCoordPos.x,m_xEndLocalCoordPos.y,m_xEndLocalCoordPos.z);
	if(m_bBeforeWeld)
		strcpy(sText,"true");
	else 
		strcpy(sText,"false");
	fprintf(fp,"<是否为焊前检测线 bBeforeWeld=\"%s\"/>\n",sText);
	fprintf(fp,"</信息>\n");
}
CAngularDimension::CAngularDimension()
{
	m_bStartLineIsDatumLine=true;
	m_hStartPart=m_hEndPart=0;
	m_fDimR=0;
}
void CAngularDimension::FromBuffer(CBuffer &buffer,long version/*=0*/,long doc_type/*=0*/)
{
	buffer.ReadBoolean(&m_bStartLineIsDatumLine);
	buffer.ReadInteger(&m_hStartPart);
	buffer.ReadInteger(&m_hEndPart);
	buffer.ReadDouble(&m_fDimR);
}
void CAngularDimension::ToBuffer(CBuffer &buffer,long version/*=0*/,long doc_type/*=0*/)
{
	buffer.WriteBoolean(m_bStartLineIsDatumLine);
	buffer.WriteInteger(m_hStartPart);
	buffer.WriteInteger(m_hEndPart);
	buffer.WriteDouble(m_fDimR);
}

void CAngularDimension::ToXmlFile(FILE* fp,DWORD schema)
{
	char sText[500]="";
	fprintf(fp,"<信息>\n");
	if(m_bStartLineIsDatumLine)
		strcpy(sText,"true");
	else 
		strcpy(sText,"false");
	fprintf(fp,"<是否以基准线为起始边 bStartLineIsDatumLine=\"%s\"/>\n",sText);
	fprintf(fp,"<进行标注的起始构件 handle=\"0x%x\"/>\n",m_hStartPart);
	fprintf(fp,"<进行标注的终止构件 handle=\"0x%x\"/>\n",m_hEndPart);
	sprintf(sText,"%f",m_fDimR);
	SimplifiedNumString(sText);
	fprintf(fp,"<标注线半径 DimR=\"%s\"/>\n",sText);
	fprintf(fp,"</信息>\n");
}
////////////////////////////////////////////////////////////////////////////////
//DRAWFLAG
////////////////////////////////////////////////////////////////////////////////
int DRAWFLAG::GetPartDrawType(CLDSPart* pPart,double* drawPlaneNorm,BYTE* cExecuteDrawFlag/*=NULL*/)
{
	int h0v1e2=-1;	//0.平铺绘制 1.侧向绘制 2.绘制端面
	f3dPoint axis_z(drawPlaneNorm);
	if(pPart->IsAngle())
	{
		int x_wing0_y_wing1=-1;
		CLDSLineAngle *pJg=(CLDSLineAngle*)pPart;
		f3dPoint cur_jg_vec=pJg->End()-pJg->Start();
		normalize(cur_jg_vec);
		BOOL bInside=-1;
		if(cDrawFlag=='X'||cDrawFlag=='S')
			x_wing0_y_wing1=0;	//X肢为当前绘制肢
		else if(cDrawFlag=='Y'||cDrawFlag=='Q')
			x_wing0_y_wing1=1;	//Y肢为当前绘制肢
		else if(cDrawFlag=='Z'||fabs(cur_jg_vec*axis_z)>0.70710)
			x_wing0_y_wing1=2;
		else
		{
			double ddx = pJg->get_norm_x_wing()*axis_z;
			double ddy = pJg->get_norm_y_wing()*axis_z;
			bInside=FALSE;
			if(fabs(ddx)>fabs(ddy))
			{
				x_wing0_y_wing1 = 0;
				if(ddx>0)	//里铁
					bInside=TRUE;
			}
			else 
			{
				x_wing0_y_wing1 = 1;
				if(ddy>0)	//里铁
					bInside=TRUE;
			}
		}
		if(bInside==-1&&x_wing0_y_wing1==0)
		{
			if(pJg->get_norm_x_wing()*axis_z>0)
				bInside=TRUE;
			else
				bInside=FALSE;
		}
		else if(bInside==-1&&x_wing0_y_wing1==1)
		{
			if(pJg->get_norm_y_wing()*axis_z>0)
				bInside=TRUE;
			else
				bInside=FALSE;
		}
		if(pJg->m_bFootNail)
		{
			f3dPoint endPt=pJg->End();
			project_point(endPt,pJg->Start(),axis_z);
			f3dPoint cur_jg_vec=endPt-pJg->Start();
			normalize(cur_jg_vec);
			if(fabs(cur_jg_vec*axis_z)>0.70710)
				x_wing0_y_wing1=2;	//角钢脚钉截面
			else
				x_wing0_y_wing1=3;	//角钢脚钉正面
		}
		if(x_wing0_y_wing1==2)
			h0v1e2=1;
		else 
			h0v1e2=0;
		if(cExecuteDrawFlag)	//角钢当前绘制肢 wht 11-08-02
		{
			if(x_wing0_y_wing1==0&&bInside)
				*cExecuteDrawFlag='X';
			else if(x_wing0_y_wing1==0&&!bInside)
				*cExecuteDrawFlag='x';
			else if(x_wing0_y_wing1==1&&bInside)
				*cExecuteDrawFlag='Y';
			else if(x_wing0_y_wing1==1&&!bInside)
				*cExecuteDrawFlag='y';
			else
				*cExecuteDrawFlag='Z';
		}
	}
	else if(pPart->GetClassTypeId()==CLS_PARAMPLATE)
	{
		CLDSParamPlate *pPlate=(CLDSParamPlate*)pPart;
		if(pPlate->m_iParamType==TYPE_ELBOWPLATE)
		{
			double dd=fabs(pPlate->ucs.axis_z*axis_z);
			if(dd>EPS_COS2)
				h0v1e2=0;
			else if(dd<0.707)
				h0v1e2=1;
		}
		else
		{	//未指定绘制方式的非肘板参数化板，提前自动判断绘制方式
			if((pPlate->m_iParamType==TYPE_UEND||pPlate->m_iParamType==TYPE_ROLLEND)
				&&fabs(axis_z*pPlate->ucs.axis_x)>EPS_COS2)
				h0v1e2=2;		//槽型插板或者U型插板需要绘制端面图即竖直绘制
			else if(fabs(axis_z*pPlate->ucs.axis_z)>0.707)
				h0v1e2=0;	//平铺绘制
			else
				h0v1e2=1;	//侧向绘制
		}
	}
	else if(pPart->GetClassTypeId()==CLS_PLATE)
	{
		CLDSPlate *pPlate=(CLDSPlate*)pPart;
		if(cDrawFlag=='X')		//平铺绘制
			h0v1e2=0;
		else if(cDrawFlag=='Z')	//竖直绘制
			h0v1e2=1;
		else if(cDrawFlag=='S'&&pPlate->face_N>1)	//展开绘制多面板
			h0v1e2=0;
		else	//未指定绘制方式，自动判断绘制方式
		{
			if(fabs(axis_z*pPlate->ucs.axis_z)>0.707)
				h0v1e2=0;	//水平绘制
			else
				h0v1e2=1;	//竖直绘制
		}
	}
	else if(pPart->IsTube())
	{
		CLDSLineTube *pLineTube=(CLDSLineTube*)pPart;
		f3dPoint len_vec=pLineTube->End()-pLineTube->Start();
		normalize(len_vec);
		if(fabs(len_vec*axis_z)<0.707)
			h0v1e2=0;
		else
			h0v1e2=1;
	}
	else if(pPart->GetClassTypeId()==CLS_LINESLOT)
	{
		if(fabs(pPart->ucs.axis_z*axis_z)>0.707)
			h0v1e2=2;	//端面
		else if(fabs(pPart->ucs.axis_y*axis_z)>0.707)
			h0v1e2=0;	//平铺
		else 
			h0v1e2=1;	//侧面
	}
	else if(pPart->GetClassTypeId()==CLS_LINEFLAT)
	{
		if(fabs(pPart->ucs.axis_x*axis_z)>0.707)
			h0v1e2=2;	//端面
		else if(fabs(pPart->ucs.axis_z*axis_z)>0.707)
			h0v1e2=0;	//平铺
		else
			h0v1e2=1;
	}
	/*else if(pPart->GetClassTypeId()==CLS_BOLT)
	{
		CLsListDraw boltDrawList;
		CLsDrawUnit *pDrawUnit=boltDrawList.AppendLsRef((CLDSBolt*)pPart,TRUE,axis_z);
		h0v1e2=pDrawUnit->front0_side1;
	}*/
	return h0v1e2;
}
////////////////////////////////////////////////////////////////////////////////
//CSectionView
////////////////////////////////////////////////////////////////////////////////
static const DWORD HASHTABLESIZE = 500;
static const DWORD STATUSHASHTABLESIZE = 50;
CStringKeyHashTable<long> CSectionView::propHashtable;
CHashTable<DWORD> CSectionView::propStatusHashtable;
void CSectionView::InitViewPropHashtable()
{
	int id=1;
	CSectionView::propHashtable.CreateHashTable(HASHTABLESIZE);
	CSectionView::propStatusHashtable.CreateHashTable(STATUSHASHTABLESIZE);
	CSectionView::propHashtable.SetValueAt("basicInfo",id++);
	CSectionView::propHashtable.SetValueAt("sName",id++);
	CSectionView::propHashtable.SetValueAt("index",id++);
	CSectionView::propHashtable.SetValueAt("m_bLocked",id++);
	CSectionView::propHashtable.SetValueAt("m_iViewType",id++);
	//
	CSectionView::propHashtable.SetValueAt("assemblePos",id++);
	CSectionView::propHashtable.SetValueAt("des_cs.m_cDefStyle",id++);
	CSectionView::propHashtable.SetValueAt("des_cs.m_eDatumPlane",id++);
	CSectionView::propHashtable.SetValueAt("ucs",id++);
	CSectionView::propHashtable.SetValueAt("ucs.origin",id++);
	CSectionView::propHashtable.SetValueAt("ucs.origin.x",id++);
	CSectionView::propHashtable.SetValueAt("ucs.origin.y",id++);
	CSectionView::propHashtable.SetValueAt("ucs.origin.z",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_x",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_x.x",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_x.y",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_x.z",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_y",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_y.x",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_y.y",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_y.z",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_z",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_z.x",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_z.y",id++);
	CSectionView::propHashtable.SetValueAt("ucs.axis_z.z",id++);
	//
	CSectionView::propHashtable.SetValueAt("m_idHostView",id++);
	CSectionView::propHashtable.SetValueAt("slaveViewPara",id++);
	CSectionView::propHashtable.SetValueAt("location",id++);		//宿主视图绘图坐标系下的剖面图符定位点坐标
	CSectionView::propHashtable.SetValueAt("location.x",id++);
	CSectionView::propHashtable.SetValueAt("location.y",id++);
	CSectionView::propHashtable.SetValueAt("location.z",id++);
	CSectionView::propHashtable.SetValueAt("direction",id++);		//宿主视图绘图坐标系下的剖面图符视线方向
	CSectionView::propHashtable.SetValueAt("direction.x",id++);
	CSectionView::propHashtable.SetValueAt("direction.y",id++);
	CSectionView::propHashtable.SetValueAt("direction.z",id++);
	CSectionView::propHashtable.SetValueAt("direct_offset",id++);	//剖面图符实际标注位置与定位点间沿视线方向的偏移距离
	CSectionView::propHashtable.SetValueAt("symbol_dist",id++);		//剖面图符(成对)间的距离
	CSectionView::propHashtable.SetValueAt("symbol",id++);		//剖面图符上的标注文字
}

long CSectionView::GetPropID(char *sProp,...)
{	//得到属性ID
	va_list ap;
	va_start(ap, sProp);
	CXhChar500 sRealProp;
	_vsnprintf((char*)sRealProp,500,sProp,ap);
	va_end(ap);
	long id;
	if(propHashtable.GetValueAt(sRealProp,id))
		return id;
	else
		return 0;
}

int CSectionView::GetPropStr(long id,char* propStr)
{
	char sText[100]="";
	
	if(propStr)
		strcpy(propStr,sText);
	return strlen(sText);
}

BOOL CSectionView::IsPropEqual(OBJSET &selectObjs, long idProp)
{
	return TRUE;
}

int CSectionView::GetPropStatus(long id)
{	
	DWORD dwStatus;
	if(CSectionView::propStatusHashtable.GetValueAt(id,dwStatus))
	{
		if(dwStatus==STATUS_EXPAND)
			return 0;	//不隐藏
		else if(dwStatus==STATUS_COLLAPSE)
			return 1;	//隐藏
	}
	return -1;	//未找到保存的状态
}

BOOL CSectionView::SetPropStatus(long id, BOOL bHide)
{
	DWORD dwStatus;
	if(bHide)
		dwStatus = STATUS_COLLAPSE;
	else
		dwStatus = STATUS_EXPAND;
	return CSectionView::propStatusHashtable.SetValueAt(id,dwStatus);
}

int CSectionView::GetPropValueStr(long id,char* valueStr)
{
	char sText[100]="";
	if(GetPropID("basicInfo")==id)
		strcpy(sText,"");
	else if(GetPropID("sName")==id)
		strcpy(sText,sName);
	else if(GetPropID("index")==id)
		sprintf(sText,"%d",index);
	else if(GetPropID("m_bLocked")==id)
	{
		if(m_bLocked)
			strcpy(sText,"是");
		else 
			strcpy(sText,"否");
	}
	else if(GetPropID("m_iViewType")==id)
	{
		if(m_iViewType==VIEW_MAIN)
			strcpy(sText,"1.主视图");
		else if(m_iViewType==VIEW_FRONT)
			strcpy(sText,"2.正视图");
		else if(m_iViewType==VIEW_NODEPLATE)
			strcpy(sText,"3.节点板端视图");
		else if(m_iViewType==VIEW_CIRCOVERPLATE)
			strcpy(sText,"4.环向肋板视图");
		else if(m_iViewType==VIEW_CIRRIBPLATE)
			strcpy(sText,"5.环向封板视图");
		else if(m_iViewType==VIEW_TUBERIBPLATE)
			strcpy(sText,"6.跨越连板视图");
		else if(m_iViewType==VIEW_FL)
			strcpy(sText,"7.法兰视图");
		else if(m_iViewType==VIEW_CIRPLATE)
			strcpy(sText,"8.环向板视图");
		else if(m_iViewType==VIEW_INSERTPLATE)
			strcpy(sText,"9.插板视图");
		else if(m_iViewType==VIEW_FOOTNAILANGLE)
			strcpy(sText,"10.角钢脚钉");
		else if(m_iViewType==VIEW_FOOTNAILSLOT)
			strcpy(sText,"11.槽钢脚钉板");
		else if(m_iViewType==VIEW_FOOT)
			strcpy(sText,"12.塔脚板");
		else if(m_iViewType==VIEW_JOINSECTION)
			strcpy(sText,"13.相贯截面图");
		else if(m_iViewType==VIEW_JOINTTUBE)
			strcpy(sText,"14.对接钢管简图");
		else if(m_iViewType==VIEW_KNODESKETCH)
			strcpy(sText,"15.K节点相贯简图");
		else //if(m_iViewType==VIEW_USERDEF)
			strcpy(sText,"100.用户定义视图");
	}
	//
	else if(GetPropID("des_cs.m_cDefStyle")==id)
	{
		if(des_cs.GetParamInfo().m_cDefStyle==1)
			strcpy(sText,"1.对称");
		else
			strcpy(sText,"0.参数化定义");	
	}
	else if(GetPropID("des_cs.m_eDatumPlane")==id)
	{
		CParaCS::PARAMETRIC_INFO param=des_cs.GetParamInfo();
		if(param.m_eDatumPlane==CParaCS::DP_XY)
			strcpy(sText,"0.X-Y面");
		else if(param.m_eDatumPlane==CParaCS::DP_YX)
			strcpy(sText,"1.Y-X面");
		else if(param.m_eDatumPlane==CParaCS::DP_YZ)
			strcpy(sText,"2.Y-Z面");
		else if(param.m_eDatumPlane==CParaCS::DP_ZY)
			strcpy(sText,"3.Z-Y面");
		else if(param.m_eDatumPlane==CParaCS::DP_ZX)
			strcpy(sText,"4.Z-X面");
		else if(param.m_eDatumPlane==CParaCS::DP_XZ)
			strcpy(sText,"5.X-Z面");
	}
	else if(GetPropID("ucs.origin.x")==id)
	{
		sprintf(sText,"%f",ucs.origin.x);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("ucs.origin.y")==id)
	{
		sprintf(sText,"%f",ucs.origin.y);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("ucs.origin.z")==id)
	{
		sprintf(sText,"%f",ucs.origin.z);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("ucs.axis_x")==id)
		strcpy(sText,des_cs.GetAxisDescription('X'));
	else if(GetPropID("ucs.axis_x.x")==id)
	{
		sprintf(sText,"%f",ucs.axis_x.x);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("ucs.axis_x.y")==id)
	{
		sprintf(sText,"%f",ucs.axis_x.y);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("ucs.axis_x.z")==id)
	{
		sprintf(sText,"%f",ucs.axis_x.z);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("ucs.axis_y")==id)
		strcpy(sText,des_cs.GetAxisDescription('Y'));
	else if(GetPropID("ucs.axis_y.x")==id)
	{
		sprintf(sText,"%f",ucs.axis_y.x);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("ucs.axis_y.y")==id)
	{
		sprintf(sText,"%f",ucs.axis_y.y);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("ucs.axis_y.z")==id)
	{
		sprintf(sText,"%f",ucs.axis_y.z);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("ucs.axis_z")==id)
		strcpy(sText,des_cs.GetAxisDescription('Z'));
	else if(GetPropID("ucs.axis_z.x")==id)
	{
		sprintf(sText,"%f",ucs.axis_z.x);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("ucs.axis_z.y")==id)
	{
		sprintf(sText,"%f",ucs.axis_z.y);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("ucs.axis_z.z")==id)
	{
		sprintf(sText,"%f",ucs.axis_z.z);
		SimplifiedNumString(sText);
	}
	if(valueStr)
		strcpy(valueStr,sText);
	return strlen(sText);
}

void LoadAssistPlane(CDrawingAssistant* pObj,DWORD key){pObj->iNo=key; }
CSectionView::CSectionView(int id)
{
	m_id=id;
	m_idViewType=CLS_BASIC_VIEW;
	strcpy(sName,"");
	//strcpy(sPartNo,"");
	m_bLocked=FALSE;
	feature=0;
	index=0;
	m_fOrgLenOffset=0.0;
	LoadDefaultUCS(&ucs);
	m_iViewType=VIEW_USERDEF;
	m_pPartGroup=NULL;
	hashAssistPlanes.LoadDefaultObjectInfo=LoadAssistPlane;
}
CSectionView::ITEM_TAG_INFO::ITEM_TAG_INFO()
{
	m_pAttachObj=NULL;
	cDrawMode=0;
	pCurPart=NULL;
}
/*void CSectionView::ITEM_TAG_INFO::AttachObject(void* pObj)
{
	m_pAttachObj=pObj;
	((PART_ITEM*)pObj)->pTagInfo=this;
}
void CSectionView::ITEM_TAG_INFO::DetachObject()
{
	if(m_pAttachObj&&((PART_ITEM*)m_pAttachObj)->pTagInfo==this)
		((PART_ITEM*)m_pAttachObj)->pTagInfo=NULL;
	m_pAttachObj=NULL;
}*/
//当PART_ITEM已经有挂接对象时执行TagInfo(...), 否则创建新挂接数据对象后返回
CSectionView::ITEM_TAG_INFO* CSectionView::LoadTagInfo(PART_ITEM* pItem)
{
	if(pItem->pTagInfo!=NULL)
		return (ITEM_TAG_INFO*)pItem->pTagInfo;
	ITEM_TAG_INFO* pTagInfo=listTagInfo.append();
	pItem->pTagInfo=pTagInfo;
	pTagInfo->AttachObject(pItem);
	return pTagInfo;
}
CSectionView::ITEM_TAG_INFO* TagInfo(CSectionView::PART_ITEM* pItem)
{
	return (CSectionView::ITEM_TAG_INFO*)pItem->pTagInfo;
}
CLDSPart* TagPart(CSectionView::PART_ITEM* pItem)
{
	if(pItem->pTagInfo!=NULL)
		return ((CSectionView::ITEM_TAG_INFO*)pItem->pTagInfo)->pCurPart;
	return NULL;
}

//添加默认的标定点
void CSectionView::AddDefaultLocatePoints(CLDSPart *pDatumPart,IModel *pTower)
{
	int i,j;
	if(pDatumPart==NULL||pDatumPart->GetClassTypeId()!=CLS_LINETUBE||(m_iViewType!=VIEW_MAIN
		&&m_iViewType!=VIEW_FRONT&&m_iViewType!=VIEW_USERDEF))
		return;	//目前只处理基准构件为钢管时的定位点添加
	CSectionView::PART_ITEM *pPartItem = NULL;
	CPartGroupLocatePoint *pLocatePoint=NULL;
	CLDSLineTube *pLineTube=(CLDSLineTube*)pDatumPart;
	if((pLineTube->m_tJointStart.type==1&&pLineTube->m_tJointStart.hViceLinkObj<0)||
		(pLineTube->m_tJointEnd.type==1&&pLineTube->m_tJointEnd.hViceLinkObj<0))
		return;		//对接相贯组焊件的相应视图特殊处理
	UCS_STRU dcs;	//以基准构件为基准的绘图坐标系
	dcs.axis_z=pLineTube->End()-pLineTube->Start();
	normalize(dcs.axis_z);
	if(fabs(dcs.axis_z*ucs.axis_z)>EPS_COS)
		return;	//端面图不添加标定点
	f3dLine line,tube_line;
	tube_line.startPt=pLineTube->Start()-dcs.axis_z*pLineTube->startOdd();
	tube_line.endPt=pLineTube->End()+dcs.axis_z*pLineTube->endOdd();
	dcs.origin=tube_line.startPt;
	//添加钢管始终端标定点
	TUBEJOINT *pTubeJoint=NULL; 
	for(i=0;i<2;i++)
	{
		if(i==0)		//始端
			pTubeJoint=&pLineTube->m_tJointStart;
		else //if(i==1)	//终端
			pTubeJoint=&pLineTube->m_tJointEnd;
		//平面切割钢管后应该添加标注值 平面切割或对接相贯
		if((pTubeJoint->type==0||(pTubeJoint->type==1&&pTubeJoint->hLinkObj>0&&pTubeJoint->hViceLinkObj<0))
			&&!pTubeJoint->cutPlaneNorm.IsZero())
		{	//钢管始端被平面切割
			double inner_radius=pLineTube->GetDiameter()/2-pLineTube->GetThick();
			f3dPoint up_vec=pTubeJoint->cutPlaneNorm-(pTubeJoint->cutPlaneNorm*dcs.axis_z)*dcs.axis_z;
			/*f3dPoint d=(dcs.axis_z^pTubeJoint->cutPlaneNorm)^dcs.axis_z;
			normalize(d);*/
			normalize(up_vec);
			if(ucs.axis_y*up_vec<0)
				up_vec*=-1.0;
			f3dPoint inters_point;
			CPartGroupLocatePoint* locatePointArr[2];
			for(j=0;j<2;j++)
			{
				if(j==0)
				{
					line.startPt=tube_line.startPt+up_vec*inner_radius;
					line.endPt=tube_line.endPt+up_vec*inner_radius;
				}
				else
				{
					line.startPt=tube_line.startPt-up_vec*inner_radius;
					line.endPt=tube_line.endPt-up_vec*inner_radius;
				}
				Int3dlf(inters_point,line,pTubeJoint->cutPlanePos,pTubeJoint->cutPlaneNorm);
				locatePointArr[j]=LocatePoints.append();
				//locatePointArr[j]->m_hPart=0;
				locatePointArr[j]->m_fLenPosToDatumPart=dcs.axis_z*(inters_point-dcs.origin);
				locatePointArr[j]->m_bDimSpace=FALSE;
			}
			if(m_iViewType==VIEW_JOINTTUBE)
			{	//相贯钢管
				locatePointArr[0]->m_hPart=pLineTube->handle;
				locatePointArr[0]->m_fVertPosToDatumPart=0.5*pLineTube->GetDiameter();
				locatePointArr[0]->m_iOrderType= 2;	//局部尺寸标定点
				locatePointArr[1]->m_hPart=pLineTube->handle;
				locatePointArr[1]->m_fVertPosToDatumPart=-0.5*pLineTube->GetDiameter();
				locatePointArr[1]->m_iOrderType= -2;	//局部尺寸标定点
			}
			else
			{
				if(locatePointArr[1]->m_fLenPosToDatumPart>locatePointArr[0]->m_fLenPosToDatumPart)
				{
					locatePointArr[0]->m_iOrderType= 0;	//上侧为端面定位点
					locatePointArr[1]->m_iOrderType=-1;	//下侧为构件定位点
					if(i==0)
						m_fOrgLenOffset=-locatePointArr[0]->m_fLenPosToDatumPart;
				}
				else
				{
					locatePointArr[0]->m_iOrderType= 1;	//上侧构件定位点
					locatePointArr[1]->m_iOrderType= 0;	//下侧端面定位点
					if(i==0)
						m_fOrgLenOffset=-locatePointArr[1]->m_fLenPosToDatumPart;
				}
			}
		}
		else 
		{
			//将钢管的始/终端作为一个基准的标定点
			pLocatePoint=LocatePoints.append();
			f3dPoint locate_point;
			if(i==0)	//始端
				locate_point=tube_line.startPt;
			else		//终端
				locate_point=tube_line.endPt;
			pLocatePoint->m_fLenPosToDatumPart=dcs.axis_z*(locate_point-dcs.origin);
			pLocatePoint->m_iOrderType=0;	//钢管端面构件定位尺寸
			pLocatePoint->m_bDimSpace=FALSE;
			CLDSParamPlate *pEndLjPlate=(CLDSParamPlate*)pTower->FromPartHandle(pTubeJoint->hLinkObj,CLS_PARAMPLATE);
			if(pEndLjPlate==NULL)
				continue;
			pLocatePoint->m_hPart=pEndLjPlate->handle;
			if(m_iViewType==VIEW_JOINTTUBE)	
			{	//为标注对接相贯钢管上下两层里皮长度,在钢管端头上下两侧分别添加一个局部尺寸标定点 wht 10-08-11
				CPartGroupLocatePoint *pTubeEndPoint=LocatePoints.append();
				pTubeEndPoint->m_fLenPosToDatumPart=dcs.axis_z*(locate_point-dcs.origin);
				pTubeEndPoint->m_iOrderType=2;	//钢管端面构件定位尺寸
				pTubeEndPoint->m_bDimSpace=FALSE;
				pTubeEndPoint->m_hPart=pLineTube->handle;
				pTubeEndPoint->m_fVertPosToDatumPart=0.5*pLineTube->GetDiameter();
				//
				pTubeEndPoint=LocatePoints.append();
				pTubeEndPoint->m_fLenPosToDatumPart=dcs.axis_z*(locate_point-dcs.origin);
				pTubeEndPoint->m_iOrderType=-2;	//钢管端面构件定位尺寸
				pTubeEndPoint->m_bDimSpace=FALSE;
				pTubeEndPoint->m_hPart=pLineTube->handle;
				pTubeEndPoint->m_fVertPosToDatumPart=-0.5*pLineTube->GetDiameter();
			}
			if( pEndLjPlate&&(pEndLjPlate->IsFL()))
			{	//法兰 平焊法兰 对焊法兰
				pLocatePoint->m_iOrderType=2;	//钢管端面局部间隙尺寸
				pLocatePoint=LocatePoints.append();
				f3dPoint origin=pEndLjPlate->ucs.origin;
				if(i==0)
					origin+=pEndLjPlate->GetOutterPlaneOffset(-dcs.axis_z)*pEndLjPlate->ucs.axis_z;
				else
					origin+=pEndLjPlate->GetOutterPlaneOffset( dcs.axis_z)*pEndLjPlate->ucs.axis_z;
				pLocatePoint->m_fLenPosToDatumPart=(origin-dcs.origin)*dcs.axis_z;
				pLocatePoint->m_iOrderType=0;	//端面定位点
				pLocatePoint->m_hPart=pEndLjPlate->handle;
				pLocatePoint->m_bDimSpace=FALSE;
				if(i==0)
					m_fOrgLenOffset=-pLocatePoint->m_fLenPosToDatumPart;
			}
			else if(pEndLjPlate&&(pEndLjPlate->m_iParamType==TYPE_XEND||
				pEndLjPlate->m_iParamType==TYPE_UEND||pEndLjPlate->m_iParamType==TYPE_ROLLEND))
			{	//钢管始端连有插板 
				//在插板上的螺栓处插入标定点，显示侧面的插板也应该添加标定点
				PARTSET partset;
				CLDSPart *pPart=NULL;
				double L=1000000,max_x=-1000;		//将插板上X坐标最大的螺栓作为定位尺寸
				CLDSBolt *pBoltMaxX=NULL;
				pEndLjPlate->GetDesignItemValue('L',&L);
				for(CLsRef *pLsRef=pEndLjPlate->GetFirstLsRef();pLsRef;pLsRef=pEndLjPlate->GetNextLsRef())
				{
					f3dPoint temp_pos,ls_pos=(*pLsRef)->ucs.origin;
					coord_trans(ls_pos,pEndLjPlate->ucs,FALSE);
					if(pEndLjPlate->m_iParamType==TYPE_XEND&&ls_pos.x>L)
						continue;	//跳过不在插板基板长度范围内的螺栓 wht 10-08-06
					if((ls_pos.x-max_x)>EPS)	//应使用EPS进行比较
					{
						max_x=ls_pos.x;
						pBoltMaxX=pLsRef->GetLsPtr();
					}
					for(pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
					{
						temp_pos=pPart->ucs.origin;
						coord_trans(temp_pos,pEndLjPlate->ucs,FALSE);
						if(fabs(ls_pos.x-temp_pos.x)<EPS2)
							break;
					}
					if(pPart==NULL)
						partset.append(pLsRef->GetLsPtr());
				}
				//此处一定会有一个X坐标最大的螺栓，在此将钢管端面标定点修改为局部间隙尺寸标定点 wht 10-08-08
				pLocatePoint->m_iOrderType=2;	
				double width=pEndLjPlate->GetPrjDrawingWidth();
				for(pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
				{
					pLocatePoint=LocatePoints.append();
					pLocatePoint->m_hPart=pEndLjPlate->handle;
					pLocatePoint->m_fLenPosToDatumPart=(pPart->ucs.origin-dcs.origin)*dcs.axis_z;
					if(pBoltMaxX&&pBoltMaxX->handle==pPart->handle)
					{
						pLocatePoint->m_iOrderType=0;	//端面定位点
						if(i==0) //绘图原点(始端插板X相对坐标最大螺栓)距离钢管原点的长度方向偏移 wht 10-08-08
							m_fOrgLenOffset=-pLocatePoint->m_fLenPosToDatumPart;
					}
					else
					{
						pLocatePoint->m_fVertPosToDatumPart=0.5*width+1; //局部间隙尺寸需要指定偏移距离
						pLocatePoint->m_iOrderType=2;	//局部间隙尺寸
					}
					pLocatePoint->m_hPart=pEndLjPlate->handle;
					pLocatePoint->m_bDimSpace=FALSE;
				}
				//插板原点处插入标定点
				pLocatePoint=LocatePoints.append();
				pLocatePoint->m_hPart=pEndLjPlate->handle;
				pLocatePoint->m_fLenPosToDatumPart=(pEndLjPlate->ucs.origin-dcs.origin)*dcs.axis_z;
				pLocatePoint->m_fVertPosToDatumPart=0.5*width+1;
				pLocatePoint->m_iOrderType=2;	//局部间隙尺寸		
				pLocatePoint->m_bDimSpace=FALSE;
			}
		}
	}
	for(pPartItem=SonParts.GetFirst();pPartItem;pPartItem=SonParts.GetNext())
	{
		CSuperSmartPtr<CLDSPart> pPart=pTower->FromPartHandle(pPartItem->hSonPart);
		if(pPart.IsNULL())
			continue;
		BOOL bNeedJudgeOrder=FALSE;			//是否需要区分上下侧标定点 wht 10-08-16
		CPartGroupLocatePoint locate_point;	//locate_point 此处要求必须有基准构件
		CLDSPart *pLocatePointPart=NULL;
		if(pPart->GetClassTypeId()==CLS_PLATE)
		{	//添加普通钢板标定点
			bNeedJudgeOrder=TRUE;
			CLDSNode *pNode=pTower->FromNodeHandle(pPart.PlatePointer()->designInfo.m_hBaseNode);
			if(pNode==NULL)
				continue;
			if(fabs(pPart->ucs.axis_z*ucs.axis_z)>0.707)	//小于45°
			{
				locate_point.m_hPart=pPart->handle;
				double locate_point_y=0;//对活点Y坐标
				PROFILE_VERTEX *pPrevPnt=pPart.PlatePointer()->vertex_list.GetTail();
				for(PROFILE_VERTEX *pVertex=pPart.PlatePointer()->vertex_list.GetFirst();pVertex;pVertex=pPart.PlatePointer()->vertex_list.GetNext())
				{
					if(pPrevPnt->m_bWeldEdge)
					{
						if(pPrevPnt->local_point_vec==1||pPrevPnt->local_point_vec==2)
						{
							locate_point_y=pPrevPnt->local_point_y;
							break;
						}
					}
					pPrevPnt = pVertex;
				}
				f3dPoint vertex(0,locate_point_y,0);
				coord_trans(vertex,pPart->ucs,TRUE);
				locate_point.m_fLenPosToDatumPart=(vertex-dcs.origin)*dcs.axis_z;
				//大致判断板的位置 上/下
				vertex=pPart.PlatePointer()->vertex_list.GetFirst()->vertex;
				coord_trans(vertex,pPart->ucs,TRUE);
				vertex-=dcs.origin;
				if(vertex*ucs.axis_y>0)
					locate_point.m_iOrderType=1;	//构件定位尺寸
				else
					locate_point.m_iOrderType=-1;	//构件定位尺寸
				locate_point.m_bDimSpace=FALSE;
				pLocatePointPart=pPart.PlatePointer();
			}
		}
		else if(pPart->GetClassTypeId()==CLS_LINESLOT)
		{	//添加脚钉底座标定点
			if(pPart.LineSlotPointer()->GetLsCount()!=1)
				continue;	
			CLDSBolt *pBolt=pPart.LineSlotPointer()->GetFirstLsRef()->GetLsPtr();
			if(pBolt==NULL)
				continue;
			if(!pBolt->IsFootNail())
				continue;	//非脚钉底座
			locate_point.m_hPart=pBolt->handle;
			locate_point.m_xLocalCoordPos.Set();
			locate_point.m_fLenPosToDatumPart=(pBolt->ucs.origin-dcs.origin)*dcs.axis_z;
			locate_point.m_iOrderType=-3;	//脚钉定位尺寸
			locate_point.m_bDimSpace=FALSE;
			pLocatePointPart=pBolt;
		}
		else if(pPart->GetClassTypeId()==CLS_LINEANGLE)
		{	//角钢脚钉
			if(!pPart.LineAnglePointer()->m_bFootNail)
				continue;
			pPart.LineAnglePointer()->getUCS(pPart->ucs);	//构建角钢坐标系
			locate_point.m_hPart=pPart->handle;
			locate_point.m_xLocalCoordPos.Set();
			locate_point.m_fLenPosToDatumPart=(pPart->ucs.origin-dcs.origin)*dcs.axis_z;
			locate_point.m_iOrderType=-3;	//脚钉底座尺寸
			locate_point.m_bDimSpace=FALSE;
			pLocatePointPart=pPart.LineAnglePointer();
		}
		else if(pPart->GetClassTypeId()==CLS_PARAMPLATE)
		{	//环向肋板
			if(pPart.ParamPlatePointer()->m_iParamType!=TYPE_CIRRIBPLATE)
				continue;
			locate_point.m_hPart=pPart->handle;
			locate_point.m_xLocalCoordPos.Set();
			locate_point.m_fLenPosToDatumPart=(pPart->ucs.origin-dcs.origin)*dcs.axis_z;
			locate_point.m_iOrderType=1;	//构件定位尺寸
			locate_point.m_bDimSpace=FALSE;
			pLocatePointPart=pPart.ParamPlatePointer();
		}
		else if(pPart->GetClassTypeId()==CLS_LINETUBE)
		{	//为钢管上的脚钉添加标定点 wht 12-08-30
			CLDSLineTube *pCurTube=pPart.LineTubePointer();
			for(CLsRef *pLsRef=pCurTube->GetFirstLsRef();pLsRef;pLsRef=pCurTube->GetNextLsRef())
			{
				if(pLsRef->GetLsPtr()==NULL||!pLsRef->GetLsPtr()->IsFootNail())
					continue;
				CPartGroupLocatePoint locatePt;
				locatePt.m_hPart=pLsRef->GetLsPtr()->handle;
				locatePt.m_xLocalCoordPos.Set();
				locatePt.m_fLenPosToDatumPart=(pLsRef->GetLsPtr()->ucs.origin-dcs.origin)*dcs.axis_z;
				locatePt.m_iOrderType=-3;	//脚钉定位尺寸
				locatePt.m_bDimSpace=FALSE;
				//避免在同一截面位置添加标定点
				for(pLocatePoint=LocatePoints.GetFirst();pLocatePoint;pLocatePoint=LocatePoints.GetNext())
				{
					if(pLocatePoint->m_fLenPosToDatumPart==locatePt.m_fLenPosToDatumPart)
					{
						if(!bNeedJudgeOrder)
							break;
						else if(pLocatePoint->m_iOrderType==locatePt.m_iOrderType)
							break;
					}
				}
				if(pLocatePoint==NULL)
					LocatePoints.append(locatePt);
			}
			//相贯支管 wht 10-08-08
			CLDSLineTube *pBranchTube=pPart.LineTubePointer(),*pMainTube=NULL,*pViceTube=NULL;
			f3dPoint branch_tube_vec;
			if(pBranchTube->m_tJointStart.type==1&&pBranchTube->m_tJointStart.hViceLinkObj>=0)
			{	//始端相贯(此处不处理对接相贯)
				if(pBranchTube->m_tJointStart.hLinkObj>0x20)
					pMainTube=(CLDSLineTube*)pTower->FromPartHandle(pBranchTube->m_tJointStart.hLinkObj,CLS_LINETUBE);
				if(pBranchTube->m_tJointStart.hViceLinkObj>0x20)
					pViceTube=(CLDSLineTube*)pTower->FromPartHandle(pBranchTube->m_tJointStart.hViceLinkObj,CLS_LINETUBE);
				branch_tube_vec=pBranchTube->End()-pBranchTube->Start();
			}
			else if(pBranchTube->m_tJointEnd.type==1&&pBranchTube->m_tJointEnd.hViceLinkObj>=0)
			{	//终端相贯(此处不处理对接相贯)
				if(pBranchTube->m_tJointEnd.hLinkObj>0x20)
					pMainTube=(CLDSLineTube*)pTower->FromPartHandle(pBranchTube->m_tJointEnd.hLinkObj,CLS_LINETUBE);
				if(pBranchTube->m_tJointEnd.hViceLinkObj>0x20)
					pViceTube=(CLDSLineTube*)pTower->FromPartHandle(pBranchTube->m_tJointEnd.hViceLinkObj,CLS_LINETUBE);
				branch_tube_vec=pBranchTube->Start()-pBranchTube->End();
			}
			normalize(branch_tube_vec);
			if(pMainTube==NULL)
				continue;
			if(pMainTube->handle!=pDatumPart->handle&&(pViceTube==NULL||
				(pViceTube&&pViceTube->handle!=pDatumPart->handle)))
				continue;
			f3dPoint inters_pos;
			int nRetCode=Int3dpl(f3dLine(pLineTube->Start(),pLineTube->End()),
				f3dLine(pBranchTube->Start(),pBranchTube->End()),inters_pos);
			if(nRetCode!=1)
				continue;
			locate_point.m_hPart=pLineTube->handle;
			locate_point.m_xLocalCoordPos.Set();
			locate_point.m_fLenPosToDatumPart=(inters_pos-dcs.origin)*dcs.axis_z;
			if(branch_tube_vec*ucs.axis_y>0)
				locate_point.m_iOrderType=1;	//构件定位尺寸
			else 
				locate_point.m_iOrderType=-1;	//构件定位尺寸
			locate_point.m_bDimSpace=FALSE;
			pLocatePointPart=pLineTube;
		}
		if(pLocatePointPart==NULL||locate_point.m_hPart<0x20)
			continue;	//无基准构件
		//避免在同一截面位置添加标定点
		for(pLocatePoint=LocatePoints.GetFirst();pLocatePoint;pLocatePoint=LocatePoints.GetNext())
		{
			if(pLocatePoint->m_fLenPosToDatumPart==locate_point.m_fLenPosToDatumPart)
			{
				if(!bNeedJudgeOrder)
					break;
				else if(pLocatePoint->m_iOrderType==locate_point.m_iOrderType)
					break;
			}
		}
		if(pLocatePoint==NULL)
			LocatePoints.append(locate_point);
	}
}

//添加默认的角度标注线
void CSectionView::AddDefaultAngulars(CLDSPart *pDatumPart,IModel *pTower)
{
	if(pDatumPart==NULL)
		return;
	CSectionView::PART_ITEM *pPartItem = NULL;
	if(pDatumPart->GetClassTypeId()==CLS_LINETUBE)
	{
		CLDSLineTube *pLineTube=(CLDSLineTube*)pDatumPart;
		pLineTube->BuildUCS();
		if(m_iViewType==VIEW_MAIN||m_iViewType==VIEW_FRONT)
			return;
		if(fabs(pLineTube->ucs.axis_z*ucs.axis_z)<EPS2)
			return;	//主/正视图的角度标注在绘制板和支管时处理,故此处跳过
		PARTSET partset[10],footNailSet;
		int nNodeNum=0,i=0,j=-1,n=SonParts.GetNodeNum();
		CHashTable<int>partsetTbl;
		partsetTbl.CreateHashTable(n);
		int nAngleNum=0;
		double angle[20];	//记录每个脚钉与基准边之间的夹角
		CLDSLineTube *pDatumRayTube=NULL;	//基准射线钢管	为支管视图添加角度标注
		f3dPoint datum_ray_tube_vec;		//基准射线钢管方向（视图坐标系下的相对方向）
		CLDSParamPlate *pXEndPlate=NULL;
		BOOL bIncludeDatumTube=FALSE;		//当前视图中是否包括基准钢管 
		for(pPartItem=SonParts.GetFirst();pPartItem;pPartItem=SonParts.GetNext())
		{
			if(pPartItem->hSonPart==pDatumPart->handle)
			{
				bIncludeDatumTube=TRUE;	
				break;
			}
		}
		CLDSLineTube *pJointTube=NULL;	//查找与基准钢管对接相贯的钢管 wht 10-08-12
		if(!bIncludeDatumTube)
		{
			for(pPartItem=SonParts.GetFirst();pPartItem;pPartItem=SonParts.GetNext())
			{	//统计连接有钢板的节点数目以及附带的钢板
				CLDSPart *pTempPart=pTower->FromPartHandle(pPartItem->hSonPart);
				if(pTempPart==NULL)
					continue;
				if(pTempPart->GetClassTypeId()!=CLS_LINETUBE)
					continue;
				CLDSLineTube *pTempTube=(CLDSLineTube*)pTempPart;
				if(pLineTube->m_tJointStart.hLinkObj!=pTempTube->handle
					&&pLineTube->m_tJointEnd.hLinkObj!=pTempTube->handle)
					continue;
				pJointTube=pTempTube;
				pJointTube->BuildUCS();
				break;
			}
		}
		for(pPartItem=SonParts.GetFirst();pPartItem;pPartItem=SonParts.GetNext())
		{	//统计连接有钢板的节点数目以及附带的钢板
			CLDSPlate *pPlate=NULL;
			CLDSPart *pPart=pTower->FromPartHandle(pPartItem->hSonPart);
			if(pPart==NULL)
				continue;
			if(pPart->GetClassTypeId()==CLS_LINESLOT)
			{	//将组焊件中与钢管基准边夹角不同的脚钉底座加入到脚钉底座列表中
				CLDSLineSlot *pLineSlot=(CLDSLineSlot*)pPart;
				if(pLineSlot==NULL)
					continue;
				pLineSlot->BuildUCS();
				if(pLineSlot->GetLsCount()!=1)
					continue;	//非脚钉底座板
				CLDSBolt *pBolt=pLineSlot->GetFirstLsRef()->GetLsPtr();
				if(pBolt==NULL)
					continue;	
				if(!pBolt->IsFootNail())
					continue;	//非脚钉底座板
				pBolt->GetUCS();
				f3dPoint ls_norm=pBolt->get_norm();
				//将螺栓法线方向转换到钢管坐标系下
				vector_trans(ls_norm,pLineTube->ucs,FALSE);
				double offset_angle=Cal2dLineAng(f2dPoint(0,0),f2dPoint(ls_norm.x,ls_norm.y))*DEGTORAD_COEF;
				BOOL bFlag=TRUE;
				for(i=0;i<nAngleNum;i++)
				{
					if(fabs(angle[i]-offset_angle)<EPS2) //误差0.03°
					{	//已存在该角度值
						bFlag=FALSE;
						break;
					}
				}
				if(bFlag)
				{	//列表没有相同的角度值
					angle[nAngleNum]=offset_angle;
					nAngleNum++;
					footNailSet.append(pLineSlot);
				}
			}
			else if(pPart->GetClassTypeId()==CLS_LINEANGLE)
			{	//角钢脚钉
				CLDSLineAngle *pLineAngle=(CLDSLineAngle*)pPart;
				if(pLineAngle==NULL)
					continue;
				if(!pLineAngle->m_bFootNail)
					continue;
				pLineAngle->getUCS(pLineAngle->ucs);
				double offset_angle=Cal2dLineAng(f2dPoint(0,0),f2dPoint(pLineAngle->ucs.axis_z.x,pLineAngle->ucs.axis_z.y))*DEGTORAD_COEF;
				BOOL bFlag=TRUE;
				for(i=0;i<nAngleNum;i++)
				{
					if(fabs(angle[i]-offset_angle)<EPS2) //误差0.03°
					{	//已存在该角度值
						bFlag=FALSE;
						break;
					}
				}
				if(bFlag)
				{	//列表没有相同的角度值
					angle[nAngleNum]=offset_angle;
					nAngleNum++;
					footNailSet.append(pLineAngle);
				}
			}
			else if(pPart->GetClassTypeId()==CLS_PLATE)
				pPlate=(CLDSPlate*)pPart;
			else if(pPart->GetClassTypeId()==CLS_LINETUBE)
			{
				if(pPart->handle==pDatumPart->handle)
					continue;
				CLDSLineTube *pRayTube=(CLDSLineTube*)pPart;
				f3dPoint ray_tube_vec=pRayTube->End()-pRayTube->Start();
				normalize(ray_tube_vec);
				project_vector(ray_tube_vec,ucs.axis_z);
				if(pDatumRayTube==NULL)
				{	//初始化基准钢管
					pDatumRayTube=pRayTube;
					datum_ray_tube_vec=ray_tube_vec;
				}
				else if(fabs(datum_ray_tube_vec*ray_tube_vec)<EPS_COS2)
				{	//添加支管角度标注
					CAngularDimension *pAngular=Angulars.append();
					pAngular->m_bStartLineIsDatumLine=!pLineTube->m_bHasWeldRoad;
					pAngular->m_hStartPart=pDatumRayTube->handle;
					pAngular->m_hEndPart=pRayTube->handle;
					pAngular->m_fDimR=150;
				}
			}
			else if(pPart->GetClassTypeId()==CLS_PARAMPLATE)
			{	//查找十字插板 用来标注十字插板立板与基板之间的夹角 wht 10-06-29
				CLDSParamPlate *pParamPlate=(CLDSParamPlate*)pPart;
				if(pParamPlate->m_iParamType==TYPE_XEND)
					pXEndPlate=pParamPlate;
			}
			if(pPlate==NULL)
				continue;
			if(pPlate->m_fInnerRadius>0)
				continue;	//跳过环形钢板不进行统计
			//某些特殊视图的基准构件不时基准钢管 wht 10-08-12
			if(bIncludeDatumTube)
			{
				if(fabs(pPlate->ucs.axis_z*pDatumPart->ucs.axis_z)>EPS2)
					continue;	//跳过不平行于钢管的钢板(环向板或者封板)
			}
			else if(pJointTube&&(fabs(pPlate->ucs.axis_z*pJointTube->ucs.axis_z)>EPS2))
				continue;	//跳过不平行于钢管的钢板(环向板或者封板))
			if(partsetTbl.GetValueAt(pPlate->designInfo.m_hBaseNode,j))
				partset[j].append(pPlate);
			else 
			{
				CLDSNode *pNode=pTower->FromNodeHandle(pPlate->designInfo.m_hBaseNode);
				if(pNode==NULL)
					continue;
				partsetTbl.SetValueAt(pPlate->designInfo.m_hBaseNode,nNodeNum);
				partset[nNodeNum].append(pPlate);
				nNodeNum++;
			}
		}
		CLDSPart *pPart=NULL;
		CAngularDimension *pAngular=NULL;
		CLDSLineSlot *pLineSlot=NULL;
		CLDSLinePart *pDatumLinePart=NULL;
		for(pPart=footNailSet.GetFirst();pPart;pPart=footNailSet.GetNext())
		{	
			if(pPart->GetClassTypeId()!=CLS_LINESLOT&&pPart->GetClassTypeId()!=CLS_LINEANGLE)
				continue;
			if(pPart->GetClassTypeId()==CLS_LINEANGLE&&!((CLDSLineAngle*)pPart)->m_bFootNail)
				continue;
			if(pDatumLinePart==NULL)
			{	//基准构件
				pDatumLinePart=(CLDSLinePart*)pPart;
				continue;
			}
			pAngular=Angulars.append();
			pAngular->m_bStartLineIsDatumLine=!pLineTube->m_bHasWeldRoad;
			pAngular->m_hStartPart=pDatumLinePart->handle;
			pAngular->m_hEndPart=pPart->handle;
			pAngular->m_fDimR=pLineTube->GetDiameter()*0.5*(Angulars.GetNodeNum()+1);
		}
		for(i=0;i<nNodeNum;i++)
		{
			CLDSPlate *pPlate=NULL, *pDatumPlate=NULL;
			pPart=partset[i].GetFirst();
			if(pPart&&pPart->GetClassTypeId()==CLS_PLATE)
				pDatumPlate=(CLDSPlate*)pPart;
			else
				continue;
			for(pPart=partset[i].GetNext();pPart;pPart=partset[i].GetNext())
			{
				if(pPart==NULL||(pPart&&pPart->GetClassTypeId()!=CLS_PLATE))
					continue;
				CLDSPlate *pPlate=(CLDSPlate*)pPart;
				pAngular=Angulars.append();
				pAngular->m_bStartLineIsDatumLine=!pLineTube->m_bHasWeldRoad;
				pAngular->m_hStartPart=pDatumPlate->handle;
				pAngular->m_hEndPart=pPlate->handle;
				pAngular->m_fDimR=pLineTube->GetDiameter()*0.5*(Angulars.GetNodeNum()+1);
			}
		}
		//暂不支持包板用角钢代替的十字插板非90度时的角度标注问题 wht 10-06-30
		if(m_iViewType==VIEW_INSERTPLATE&&pXEndPlate)
		{	
			ATTACHPART_ITEM *pItem=NULL;
			CLDSPlate *pVertPlate[2]={NULL,NULL};
			for(pItem=pXEndPlate->GetFirstAttachPart();pItem;pItem=pXEndPlate->GetNextAttachPart())
			{
				CLDSPlate *pPlate=(CLDSPlate*)pXEndPlate->BelongModel()->FromPartHandle(pItem->h,CLS_PLATE);
				if(pPlate==NULL)
					continue;
				f3dPoint plate_pos=pPlate->ucs.origin;
				coord_trans(plate_pos,pXEndPlate->ucs,FALSE);
				if(plate_pos.x<EPS&&plate_pos.y<EPS)
				{
					if(pVertPlate[0]==NULL)
						pVertPlate[0]=pPlate;	//立板1
					else if(pVertPlate[1]==NULL)
						pVertPlate[1]=pPlate;	//立板2
					else
						break;
				}
			}
			if(pVertPlate[0]&&pVertPlate[1])
			{	
				for(int i=0;i<2;i++)
				{
					f3dPoint norm_vec=pVertPlate[i]->ucs.axis_z;
					vector_trans(norm_vec,pXEndPlate->ucs,FALSE);
					if(fabs(norm_vec*f3dPoint(0,1,0))<EPS_COS)
					{
						pAngular=Angulars.append();
						pAngular->m_bStartLineIsDatumLine=!pLineTube->m_bHasWeldRoad;
						pAngular->m_hStartPart=pXEndPlate->handle;
						pAngular->m_hEndPart=pVertPlate[i]->handle;
						pAngular->m_fDimR=pVertPlate[i]->GetWidth()*0.5;
					}
				}
			}
		}
	}
	else if(pDatumPart->GetClassTypeId()==CLS_PLATE)
	{
		CLDSPlate *pSonPlate=NULL;
		CLDSPlate *pDatumPlate=(CLDSPlate*)pDatumPart;
		CLDSLinePart *pLinePart=(CLDSLinePart*)pTower->FromPartHandle(pDatumPlate->designInfo.m_hBasePart,CLS_LINEPART);
		if(pLinePart&&pLinePart->GetClassTypeId()==CLS_GROUPLINEANGLE)
		{
			f3dPoint len_vec=pLinePart->Start()-pLinePart->End();
			normalize(len_vec);
			if(fabs(len_vec*ucs.axis_z)<EPS2)
				return;	//正视图不需要标注角度
			CLDSGroupLineAngle *pGroupLineAngle=NULL;
			pGroupLineAngle=(CLDSGroupLineAngle*)pLinePart;
			for(pPartItem=SonParts.GetFirst();pPartItem;pPartItem=SonParts.GetNext())
			{	
				CLDSPlate *pPlate=(CLDSPlate*)pTower->FromPartHandle(pPartItem->hSonPart,CLS_PLATE);
				if(pPlate&&pPlate->designInfo.m_hBaseNode==pDatumPlate->designInfo.m_hBaseNode
					&&pPlate->designInfo.m_hBasePart==pDatumPlate->designInfo.m_hBasePart&&pPlate->handle!=pDatumPlate->handle)
				{	//找到一块与基准钢板基准节点以及基准构件均相同的钢板（排除加劲板）
					pSonPlate=pPlate;
					break;
				}
			}
			if(pGroupLineAngle&&pSonPlate)
			{
				CAngularDimension *pAngular=Angulars.append();
				pAngular->m_bStartLineIsDatumLine=FALSE;
				pAngular->m_hStartPart=pDatumPart->handle;
				pAngular->m_hEndPart=pSonPlate->handle;
				pAngular->m_fDimR=150;
			}
		}
		else if(pLinePart&&pLinePart->GetClassTypeId()==CLS_LINEANGLE)
		{	//塔脚板 牛蹄板
			//...
		}
	}
}

static BOOL CalFLAndPlateInters(CLDSParamPlate *pFL,CLDSBolt *pBolt,f3dPoint &inters_vertex)
{	
	if(pBolt==NULL)
	{
		logerr.Log("计算法兰与钢板间检测线时，遭遇螺栓为空！");
		return FALSE;
	}
	CLDSPlate *pPlate=(CLDSPlate*)pFL->BelongModel()->FromPartHandle(pBolt->feature,CLS_PLATE);
	if(pPlate==NULL)
	{
		logerr.Log("计算法兰与钢板间检测线时，遭遇钢板为空！");
		return FALSE;
	}
	//1.钢管所在平面与法兰上端面所在面求交
	f3dPoint inters_pick,inters_line_vec;
	f3dPoint face1_pick=pFL->ucs.origin+pFL->ucs.axis_z*pFL->GetThick();
	if(Int3d2f(&inters_pick,&inters_line_vec,face1_pick,pFL->ucs.axis_z,pPlate->ucs.origin,pPlate->ucs.axis_z)==1)
	{	//2.面面求交，求得的交线与法兰外圆球交点，取离基准点较近的点
		//2.1 将交线方向转换到法兰坐标系下
		normalize(inters_line_vec);
		vector_trans(inters_line_vec,pFL->ucs,FALSE);
		inters_pick.z=inters_line_vec.z=0;
		//2.2 线与圆求交
		double D=0;
		if(pFL->m_iParamType==TYPE_FL||
			pFL->m_iParamType==TYPE_FLG||
			pFL->m_iParamType==TYPE_FLR)
			pFL->GetDesignItemValue('W',&D);
		else
			pFL->GetDesignItemValue('D',&D);
		f3dPoint startPt=inters_line_vec*D,endPt=-inters_line_vec*D;
		f2dLine line(f2dPoint(startPt.x,startPt.y),f2dPoint(endPt.x,endPt.y));
		f3dPoint inters_vertex1,inters_vertex2;
		//2.3 交线与法兰外圆求交点
		int nRetCode=Int2dlc(line,f2dCircle(0.5*D,0,0),inters_vertex1.x,inters_vertex1.y,inters_vertex2.x,inters_vertex2.y);
		inters_vertex1.z=inters_vertex2.z=pFL->GetThick();
		coord_trans(inters_vertex1,pFL->ucs,TRUE);
		coord_trans(inters_vertex2,pFL->ucs,TRUE);
		if(nRetCode==1)
			inters_vertex=inters_vertex1;
		else if(nRetCode==2) 
		{
			if(DISTANCE(inters_vertex1,pBolt->ucs.origin)>DISTANCE(inters_vertex2,pBolt->ucs.origin))
				inters_vertex=inters_vertex2;
			else 
				inters_vertex=inters_vertex1;
		}
		else 
			return FALSE;
		return TRUE;
	}
	return FALSE;
}

static void AddCheckLinesByBoltSet(CSectionView *pSectionView,CLDSLineTube *pLineTube,
									BOLTSET &partSet,BOOL bDimUpCheckLine)
{	//添加检测线
	CLsRef *pLsRef=NULL;
	CCheckLineDimension checkLine,*pCheckLine=NULL;
	CLDSPart *pPart=NULL,*pDownPart=NULL,*pPrePart=NULL;
	//1 添加检测线
	//1.1 在始端构件与UpPartSet第一个构件之间以及UPdateSet相邻两构件之间添加检测线
	CLDSParamPlate *pStartParamPlate=(CLDSParamPlate*)pLineTube->BelongModel()->FromPartHandle(pLineTube->m_tJointStart.hLinkObj,CLS_PARAMPLATE);
	CLDSParamPlate *pEndParamPlate=(CLDSParamPlate*)pLineTube->BelongModel()->FromPartHandle(pLineTube->m_tJointEnd.hLinkObj,CLS_PARAMPLATE);
	if(pStartParamPlate)
		pPrePart=pStartParamPlate;
	for(pPart=partSet.GetFirst();pPart;pPart=partSet.GetNext())
	{
		if(pPart->GetClassTypeId()==CLS_BOLT)
		{	//焊前检测线
			pCheckLine=pSectionView->CheckLines.append();
			pCheckLine->m_hStartPart=pPart->handle;
			pCheckLine->m_hEndPart=pLineTube->handle;
			pCheckLine->m_bBeforeWeld=TRUE;
		}
		if(pPrePart)
		{	//焊接后检测线
			if(pPrePart->GetClassTypeId()==CLS_PARAMPLATE)
			{
				CLDSParamPlate *pParamPlate=(CLDSParamPlate*)pPrePart;
				if(pParamPlate->IsFL())
				{
					/*double D=0,fBoltR=0; 
					if(pParamPlate->m_iParamType==TYPE_FL||
						pParamPlate->m_iParamType==TYPE_FLG||
						pParamPlate->m_iParamType==TYPE_FLR)
						pParamPlate->GetDesignItemValue('W',&D);
					else
						pParamPlate->GetDesignItemValue('D',&D);
					f3dPoint pos(0,0.5*D,0);
					coord_trans(pos,pSectionView->ucs,TRUE);
					//f3dPoint pos=pParamPlate->ucs.origin+ucs.axis_y*0.5*D;
					coord_trans(pos,pParamPlate->ucs,FALSE);
					checkLine.m_xStartLocalCoordPos.Set(pos.x,pos.y,pParamPlate->GetThick());*/
					f3dPoint inters_vertex;
					if(CalFLAndPlateInters(pParamPlate,(CLDSBolt*)pPart,inters_vertex))
					{
						checkLine.m_xStartLocalCoordPos=inters_vertex;
						coord_trans(checkLine.m_xStartLocalCoordPos,pParamPlate->ucs,FALSE);
					}
					else 
						logerr.Log("组焊件0x%X-视图%s,添加检测线时错误，出错构件(0x%X)",
						pSectionView->BelongPartGroup()->handle,pSectionView->sName,pParamPlate->handle);
				}
				else if(pParamPlate->m_iParamType==TYPE_UEND||pParamPlate->m_iParamType==TYPE_ROLLEND
					||pParamPlate->m_iParamType==TYPE_XEND)
				{
					if(pParamPlate->m_iParamType!=TYPE_XEND&&fabs(pParamPlate->ucs.axis_z*pSectionView->ucs.axis_z)<EPS_COS2)
					{
						pPrePart=pPart;
						continue;	//该插板在当前视图中显示侧面
					}
					CLDSBolt *pCurBolt=NULL;
					double max_y=-1000000,min_y=1000000,L=10000000;
					pParamPlate->GetDesignItemValue('L',&L);
					for(pLsRef=pParamPlate->GetFirstLsRef();pLsRef;pLsRef=pParamPlate->GetNextLsRef())
					{
						if(fabs((*pLsRef)->get_norm()*pSectionView->ucs.axis_z)<EPS_COS2)
							continue;	//跳过插板上法线方向与当前视图Z方向不同的螺栓
						f3dPoint ls_pos=pLsRef->GetLsPtr()->ucs.origin;
						coord_trans(ls_pos,pSectionView->ucs,FALSE);
						if(pParamPlate->m_iParamType==TYPE_XEND&&ls_pos.x>L)
							continue;	//跳过不在插板基板长度范围内的螺栓 wht 10-08-06
						if(bDimUpCheckLine)
						{
							if(ls_pos.y<max_y)	//Y坐标最大
								continue;
							pCurBolt=pLsRef->GetLsPtr();
							max_y=ls_pos.y;
						}
						else
						{
							if(ls_pos.y>min_y)	//Y坐标最小
								continue;
							pCurBolt=pLsRef->GetLsPtr();
							min_y=ls_pos.y;
						}
					}
					pPrePart=pCurBolt;
				}
				else
				{
					pPrePart=pPart;
					continue;
				}
			}
			else 
				checkLine.m_xStartLocalCoordPos.Set();
			if(pPrePart)
			{
				if(pPrePart->GetClassTypeId()==CLS_BOLT&&pPart->GetClassTypeId()==CLS_BOLT&&pPrePart->feature==pPart->feature)
				{
					pPrePart=pPart;
					continue;	//同一钢板上的螺栓不需要添加焊后检测线
				}
				//检测尺寸除第一个和最后一个构件可能不为螺栓外，其余构件都为螺栓
				//故m_xStartLocalCoordPos需要单独计算,m_xEndLocalCoordPos设置为(0,0,0)即可 wht 11-07-18
				checkLine.m_xEndLocalCoordPos.Set();
				checkLine.m_hStartPart=pPrePart->handle;
				checkLine.m_hEndPart=pPart->handle;
				checkLine.m_bBeforeWeld=FALSE;
				pSectionView->CheckLines.append(checkLine);
			}
		}
		pPrePart=pPart;
	}
	CLDSBolt* pEndBolt=(CLDSBolt*)partSet.GetTail();
	//1.2 添加终端构件与partSet最后一个构件之间的检测线
	if(pEndParamPlate&&partSet.GetNodeNum()>0&&pEndParamPlate->handle!=pEndBolt->handle)
	{
		CLDSPart *pEndPart=pEndParamPlate;
		if(pEndParamPlate->IsFL())
		{
			/*double D=0;
			if(pEndParamPlate->m_iParamType==TYPE_FL||
				pEndParamPlate->m_iParamType==TYPE_FLG||
				pEndParamPlate->m_iParamType==TYPE_FLR)
				pEndParamPlate->GetDesignItemValue('W',&D);
			else
				pEndParamPlate->GetDesignItemValue('D',&D);
			f3dPoint pos(0,0.5*D,0);
			coord_trans(pos,pSectionView->ucs,TRUE);
			//f3dPoint pos=pEndParamPlate->ucs.origin+ucs.axis_y*0.5*D;
			coord_trans(pos,pEndParamPlate->ucs,FALSE);
			checkLine.m_xEndLocalCoordPos.Set(pos.x,pos.y,pEndParamPlate->GetThick());*/
			f3dPoint inters_vertex;
			if(CalFLAndPlateInters(pEndParamPlate,pEndBolt,inters_vertex))
			{
				checkLine.m_xEndLocalCoordPos=inters_vertex;
				coord_trans(checkLine.m_xEndLocalCoordPos,pEndParamPlate->ucs,FALSE);
			}
			else 
				logerr.Log("组焊件0x%X-视图%s,添加检测线时错误，出错构件(0x%X)",
				pSectionView->BelongPartGroup()->handle,pSectionView->sName,pEndParamPlate->handle);
		}
		else if(pEndParamPlate->m_iParamType==TYPE_UEND||pEndParamPlate->m_iParamType==TYPE_ROLLEND
			||pEndParamPlate->m_iParamType==TYPE_XEND)
		{
			if(pEndParamPlate->m_iParamType!=TYPE_XEND&&fabs(pEndParamPlate->ucs.axis_z*pSectionView->ucs.axis_z)<EPS_COS2)
				pEndPart=NULL;	//该插板在当前视图中显示侧面
			else
			{
				CLDSBolt *pCurBolt=NULL;
				double max_y=-1000000,min_y=1000000,L=1000000;
				pEndParamPlate->GetDesignItemValue('L',&L);
				for(pLsRef=pEndParamPlate->GetFirstLsRef();pLsRef;pLsRef=pEndParamPlate->GetNextLsRef())
				{
					if(fabs((*pLsRef)->get_norm()*pSectionView->ucs.axis_z)<EPS_COS2)
						continue;	//跳过插板上法线方向与当前视图Z方向不同的螺栓
					f3dPoint ls_pos=pLsRef->GetLsPtr()->ucs.origin;
					coord_trans(ls_pos,pSectionView->ucs,FALSE);
					if(pEndParamPlate->m_iParamType==TYPE_XEND&&ls_pos.x>L)
						continue;	//跳过不在插板基板长度范围内的螺栓 wht 10-08-06
					if(bDimUpCheckLine)
					{
						if(ls_pos.y<max_y)		//Y坐标最大
							continue;	
						pCurBolt=pLsRef->GetLsPtr();
						max_y=ls_pos.y;
					}
					else
					{
						if(ls_pos.y>min_y)		//Y坐标最小
							continue;
						pCurBolt=pLsRef->GetLsPtr();
						min_y=ls_pos.y;
					}
				}
				pEndPart=pCurBolt;
			}
		}
		else 
			checkLine.m_xEndLocalCoordPos.Set();
		if(pEndPart)
		{
			//检测尺寸除第一个和最后一个构件可能不为螺栓外，其余构件都为螺栓
			//m_xEndLocalCoordPos单独计算,m_xStartLocalCoordPos设置为(0,0,0) wht 11-07-18
			checkLine.m_xStartLocalCoordPos.Set();
			checkLine.m_hStartPart=partSet.GetTail()->handle;
			checkLine.m_hEndPart=pEndPart->handle;
			checkLine.m_bBeforeWeld=FALSE;
			pSectionView->CheckLines.append(checkLine);
		}
	}
}
//获取钢管端连接参数化板上的指定检测点
CLDSPart* GetTubeJointPart(CLDSLineTube* pLineTube,BOOL bIntersect);
BOOL GetTubeCheckPoint(CLDSLineTube* pLineTube,BOOL bLeft,f3dPoint workPlaneNorm,f3dPoint &checkPt,BOOL bStart=FALSE)
{
	CLDSPart* pPart=NULL;
	f3dPoint datumPt,datumVec;
	BOOL bJointTube=FALSE;
	if(pLineTube->m_tJointStart.type>=2 && pLineTube->m_tJointEnd.type>=2)
	{
		if(bStart)
		{
			pPart=pLineTube->BelongModel()->FromPartHandle(pLineTube->m_tJointStart.hLinkObj);
			datumVec=pLineTube->Start()-pLineTube->End();
			normalize(datumVec);
			datumPt=pLineTube->Start()+datumVec*pLineTube->startOdd();
		}
		else
		{	
			pPart=pLineTube->BelongModel()->FromPartHandle(pLineTube->m_tJointEnd.hLinkObj);
			datumVec=pLineTube->End()-pLineTube->Start();
			normalize(datumVec);
			datumPt=pLineTube->End()+datumVec*pLineTube->endOdd();
		}
	}
	else if(pLineTube->m_tJointStart.type==1 || pLineTube->m_tJointEnd.type==1)
	{
		bJointTube=TRUE;
		pPart=GetTubeJointPart(pLineTube,FALSE);
		if(pLineTube->m_tJointStart.type==1)
		{
			datumVec=pLineTube->End()-pLineTube->Start();
			normalize(datumVec);
			datumPt=pLineTube->End()+datumVec*pLineTube->endOdd();
		}
		else
		{
			datumVec=pLineTube->Start()-pLineTube->End();
			normalize(datumVec);
			datumPt=pLineTube->Start()+datumVec*pLineTube->startOdd();
		}
	}
	else
		return FALSE;
	if(pPart==NULL || pPart->GetClassTypeId()!=CLS_PARAMPLATE)
	{
		logerr.Log("%X钢管端连接构件没有参数板！",pLineTube->handle);
		return FALSE;
	}
	UCS_STRU ucs;
	ucs.origin=datumPt;
	ucs.axis_x=datumVec;
	ucs.axis_z=workPlaneNorm;
	ucs.axis_y=ucs.axis_z^ucs.axis_x;
	CLDSParamPlate* pParaPlate=(CLDSParamPlate*)pPart;
	if(pParaPlate->IsFL())
	{
		double H=0,W=0;
		pParaPlate->GetDesignItemValue('H',&H);
		pParaPlate->GetDesignItemValue('W',&W);
		datumPt=datumPt+datumVec*H;
		if(bLeft)
			checkPt=datumPt+ucs.axis_y*W*0.5;
		else
			checkPt=datumPt-ucs.axis_y*W*0.5;
	}
	else if(pParaPlate->m_iParamType==TYPE_UEND||pParaPlate->m_iParamType==TYPE_ROLLEND
		||pParaPlate->m_iParamType==TYPE_XEND)
	{
		double max_x=-10000,min_x=10000,max_y=-10000,min_y=10000,L=100000;
		CXhChar50 lsXValue,lsYValue;
		pParaPlate->GetDesignItemValue('L',&L);
		for(CLsRef* pLsRef=pParaPlate->GetFirstLsRef();pLsRef;pLsRef=pParaPlate->GetNextLsRef())
		{
			f3dPoint ls_pos=pLsRef->GetLsPtr()->ucs.origin;
			coord_trans(ls_pos,ucs,FALSE);
			lsXValue.Printf("%.f",ls_pos.x);
			lsYValue.Printf("%.f",ls_pos.y);
			if(bLeft)
			{
				if(atoi(lsYValue)<max_y || atoi(lsXValue)<max_x)	//Y坐标最大且X坐标最大
					continue;
				max_y=atoi(lsYValue);
				max_x=atoi(lsXValue);
				checkPt=ls_pos;
			}
			else
			{
				if(atoi(lsYValue)>min_y || atoi(lsXValue)<max_x)	//Y坐标最小且X坐标最大
					continue;
				min_y=atoi(lsYValue);
				max_x=atoi(lsXValue);
				checkPt=ls_pos;
			}
		}
		coord_trans(checkPt,ucs,TRUE);
	}
	return TRUE;
}
//获取钢管的端连接构件
CLDSPart* GetTubeJointPart(CLDSLineTube* pLineTube,BOOL bIntersect)
{
	if(pLineTube==NULL)
		return NULL;
	IModel* pModel=pLineTube->BelongModel();
	if(pLineTube->m_tJointStart.type==1)		//始端相贯
	{
		if(bIntersect)		//相贯处构件
			return pModel->FromPartHandle(pLineTube->m_tJointStart.hLinkObj);
		else				//非相贯处构件
			return pModel->FromPartHandle(pLineTube->m_tJointEnd.hLinkObj);
	}
	else if(pLineTube->m_tJointEnd.type==1)		//终端相贯
	{
		if(bIntersect)		//相贯处构件
			return pModel->FromPartHandle(pLineTube->m_tJointEnd.hLinkObj);
		else				//非相贯处构件
			return pModel->FromPartHandle(pLineTube->m_tJointStart.hLinkObj);
	}
	else
		return NULL;
}
//增加相贯支管检测线(支管参数化板到主管参数化板的距离)
static void AddCheckLinesByTubeSet(CSectionView *pSectionView,CLDSLineTube* pDatumTube,TUBESET &RayTubeSet,BOOL bDimUpCheckLine)
{
	//1、获取基准钢管的始终端检测点
	IModel* pModel=pDatumTube->BelongModel();
	f3dPoint startCheckPt,endCheckPt;
	if(pDatumTube->m_tJointStart.type>=2&&pDatumTube->m_tJointEnd.type>=2)			//无相贯钢管
	{	
		if(bDimUpCheckLine)
		{
			GetTubeCheckPoint(pDatumTube,FALSE,pSectionView->ucs.axis_z,startCheckPt,TRUE);
			GetTubeCheckPoint(pDatumTube,TRUE,pSectionView->ucs.axis_z,endCheckPt,FALSE);
		}
		else
		{
			GetTubeCheckPoint(pDatumTube,TRUE,pSectionView->ucs.axis_z,startCheckPt,TRUE);
			GetTubeCheckPoint(pDatumTube,FALSE,pSectionView->ucs.axis_z,endCheckPt,FALSE);
		}
	}
	else if((pDatumTube->m_tJointStart.type==1&&pDatumTube->m_tJointStart.hViceLinkObj<0) 
		|| (pDatumTube->m_tJointEnd.type==1&&pDatumTube->m_tJointEnd.hViceLinkObj<0))	//对接相贯钢管
	{	
		CLDSLineTube* pJointTube=(CLDSLineTube*)GetTubeJointPart(pDatumTube,TRUE);
		if(bDimUpCheckLine)
		{
			GetTubeCheckPoint(pDatumTube,FALSE,pSectionView->ucs.axis_z,startCheckPt);
			GetTubeCheckPoint(pJointTube,TRUE,pSectionView->ucs.axis_z,endCheckPt);
		}
		else
		{
			GetTubeCheckPoint(pDatumTube,TRUE,pSectionView->ucs.axis_z,startCheckPt);
			GetTubeCheckPoint(pJointTube,FALSE,pSectionView->ucs.axis_z,endCheckPt);
		}
	}
	else
		return;
	if(startCheckPt.IsZero() || endCheckPt.IsZero())
	{
		logerr.Log("%X基准钢管端连接没有参数化板!",pDatumTube->handle);
		return;
	}
	//2、始端参数化板与ParaPlateSet第一个构件间检测线及ParaPlateSet相邻构件之间的检测线
	f3dPoint startPt=startCheckPt,endPt,vertex1,vertex2;
	for(CLDSLineTube* pRayTube=RayTubeSet.GetFirst();pRayTube;pRayTube=RayTubeSet.GetNext())
	{
		CLDSPart* pPart=GetTubeJointPart(pRayTube,FALSE);
		if(pPart==NULL || pPart->GetClassTypeId()!=CLS_PARAMPLATE)
			continue;
		if(bDimUpCheckLine)
		{
			GetTubeCheckPoint(pRayTube,TRUE,pSectionView->ucs.axis_z,vertex1);
			GetTubeCheckPoint(pRayTube,FALSE,pSectionView->ucs.axis_z,vertex2);
		}
		else
		{	
			GetTubeCheckPoint(pRayTube,FALSE,pSectionView->ucs.axis_z,vertex1);
			GetTubeCheckPoint(pRayTube,TRUE,pSectionView->ucs.axis_z,vertex2);
		}
		//添加检测线
		endPt=vertex1;
		CCheckLineDimension *pCheckLine=pSectionView->CheckLines.append();
		pCheckLine->m_bSpecStartLocatePart=FALSE;
		pCheckLine->m_xStartLocalCoordPos=startPt;
		pCheckLine->m_bSpecEndLocatePart=FALSE;
		pCheckLine->m_xEndLocalCoordPos=endPt;
		pCheckLine->m_bBeforeWeld=FALSE;
		//
		startPt=vertex2;
	}
	//3、添加终端参数化板与RayTubeSet最后一个构件之间的检测线
	endPt=endCheckPt;
	CCheckLineDimension *pCheckLine=pSectionView->CheckLines.append();
	pCheckLine->m_bSpecStartLocatePart=FALSE;
	pCheckLine->m_xStartLocalCoordPos=startPt;
	pCheckLine->m_bSpecEndLocatePart=FALSE;
	pCheckLine->m_xEndLocalCoordPos=endPt;
	pCheckLine->m_bBeforeWeld=FALSE;
}
BOOL CSectionView::IsExistIntersectTube(CLDSLineTube *pDatumTube,IModel *pTower)
{
	if(pDatumTube==NULL)
		return FALSE;
	for(CSectionView::PART_ITEM *pPartItem=SonParts.GetFirst();pPartItem;pPartItem=SonParts.GetNext())
	{
		CLDSPart* pPart=pTower->FromPartHandle(pPartItem->hSonPart);
		if(pPart==NULL || pPart->GetClassTypeId()!=CLS_LINETUBE)
			continue;
		CLDSLineTube* pLineTube=(CLDSLineTube*)pPart;
		if(fabs(pLineTube->ucs.axis_z*ucs.axis_z)>EPS_COS)	//过滤钢管端面图
			continue;
		if(pLineTube->m_tJointStart.hLinkObj==pDatumTube->handle&&pLineTube->m_tJointStart.type==1
			&&pLineTube->m_tJointStart.hViceLinkObj>=0)	//支管始端相贯
			return TRUE;
		else if(pLineTube->m_tJointEnd.hLinkObj==pDatumTube->handle&&pLineTube->m_tJointEnd.type==1
			&&pLineTube->m_tJointEnd.hViceLinkObj>=0)	//支管终端相贯
			return TRUE;
	}
	return FALSE;
}
struct JOINTRAYTUBE	: public ICompareClass 
{
	THANDLE hRayTube;
	double fDist;
	virtual int Compare(const ICompareClass *pCompareObj)const{
		JOINTRAYTUBE* pCopareTube=(JOINTRAYTUBE*)pCompareObj;
		return this->fDist>pCopareTube->fDist;
	}
};
void CSectionView::AppendIntersectTubeCheckLines(CLDSLineTube* pDatumTube,IModel* pTower)
{
	if(pDatumTube==NULL)
		return;
	//端面图不添加检测线
	if(fabs(pDatumTube->ucs.axis_z*ucs.axis_z)>EPS_COS)
		return;
	//1、查找相贯支管集合并进行上下分组
	ARRAY_LIST<JOINTRAYTUBE> upRayTubeList;		//统计视图上侧添加检测线的支管
	ARRAY_LIST<JOINTRAYTUBE> downRayTubeList;	//统计视图下册添加检测线的支管
	f3dPoint origin=ucs.origin,vertex;
	JOINTRAYTUBE* pRayTubeInfo=NULL;
	for(CSectionView::PART_ITEM *pPartItem=SonParts.GetFirst();pPartItem;pPartItem=SonParts.GetNext())
	{
		CLDSPart* pPart=pTower->FromPartHandle(pPartItem->hSonPart);
		if(pPart==NULL || pPart->GetClassTypeId()!=CLS_LINETUBE)
			continue;
		CLDSLineTube* pLineTube=(CLDSLineTube*)pPart;
		if(fabs(pLineTube->ucs.axis_z*ucs.axis_z)>EPS_COS)
			continue;
		f3dPoint len_vec;
		if(pLineTube->m_tJointStart.hLinkObj==pDatumTube->handle&&pLineTube->m_tJointStart.type==1
			&&pLineTube->m_tJointStart.hViceLinkObj>=0)	//钢管始端相贯
		{
			len_vec=pLineTube->End()-pLineTube->Start();
			normalize(len_vec);
			vertex=pLineTube->End()+len_vec*pLineTube->endOdd();
			Int3dlf(vertex,vertex,ucs.axis_y,origin,ucs.axis_y);
			if(len_vec*ucs.axis_y>0)
			{
				pRayTubeInfo=upRayTubeList.append();
				pRayTubeInfo->hRayTube=pLineTube->handle;
				pRayTubeInfo->fDist=DISTANCE(origin,vertex);
			}
			else
			{
				pRayTubeInfo=downRayTubeList.append();
				pRayTubeInfo->hRayTube=pLineTube->handle;
				pRayTubeInfo->fDist=DISTANCE(origin,vertex);
			}
		}
		else if(pLineTube->m_tJointEnd.hLinkObj==pDatumTube->handle&&pLineTube->m_tJointEnd.type==1
			&&pLineTube->m_tJointEnd.hViceLinkObj>=0)	//钢管终端相贯
		{	
			len_vec=pLineTube->Start()-pLineTube->End();
			normalize(len_vec);
			vertex=pLineTube->Start()+len_vec*pLineTube->startOdd();
			Int3dlf(vertex,vertex,ucs.axis_y,origin,ucs.axis_y);
			if(len_vec*ucs.axis_y>0)
			{
				pRayTubeInfo=upRayTubeList.append();
				pRayTubeInfo->hRayTube=pLineTube->handle;
				pRayTubeInfo->fDist=DISTANCE(origin,vertex);
			}
			else
			{	
				pRayTubeInfo=downRayTubeList.append();
				pRayTubeInfo->hRayTube=pLineTube->handle;
				pRayTubeInfo->fDist=DISTANCE(origin,vertex);
			}
		}
	}
	//2、添加上检测线
	int upRayTubeNum=upRayTubeList.GetSize();
	if(upRayTubeNum>0)
	{
		//对上侧支管集合进行排序
		if(upRayTubeNum>1)
			CQuickSort<JOINTRAYTUBE>::QuickSortClassic(upRayTubeList.m_pData,upRayTubeNum);
		TUBESET upRayTubeSet;
		for(pRayTubeInfo=upRayTubeList.GetFirst();pRayTubeInfo;pRayTubeInfo=upRayTubeList.GetNext())
		{
			CLDSLineTube* pRayTube=(CLDSLineTube*)pTower->FromPartHandle(pRayTubeInfo->hRayTube);
			upRayTubeSet.append(pRayTube);
		}
		//添加检测线
		AddCheckLinesByTubeSet(this,pDatumTube,upRayTubeSet,TRUE);
	}
	//3、添加下检测线
	int downRayTubeNum=downRayTubeList.GetSize();
	if(downRayTubeNum>0)
	{
		//对下侧钢管集合进行排序
		if(downRayTubeNum>1)
			CQuickSort<JOINTRAYTUBE>::QuickSortClassic(downRayTubeList.m_pData,downRayTubeNum);
		TUBESET downRayTubeSet;
		for(pRayTubeInfo=downRayTubeList.GetFirst();pRayTubeInfo;pRayTubeInfo=downRayTubeList.GetNext())
		{
			CLDSLineTube* pRayTube=(CLDSLineTube*)pTower->FromPartHandle(pRayTubeInfo->hRayTube);
			downRayTubeSet.append(pRayTube);
		}
		//添加检测线
		AddCheckLinesByTubeSet(this,pDatumTube,downRayTubeSet,FALSE);
	}
}
//添加默认的检测线
void CSectionView::AddDefaultCheckLines(CLDSPart *pDatumPart,IModel *pTower)
{
	if(pDatumPart==NULL)
		return;
	CLogErrorLife loglife;
	CCheckLineDimension *pCheckLine=NULL;
	CSectionView::PART_ITEM *pPartItem = NULL;
	if(pDatumPart->GetClassTypeId()==CLS_LINETUBE)
	{
		CLDSLineTube *pLineTube=(CLDSLineTube*)pDatumPart;
		pLineTube->BuildUCS();
		if(m_iViewType!=VIEW_MAIN&&m_iViewType!=VIEW_FRONT&&m_iViewType!=VIEW_USERDEF)
			return;
		if(fabs(pLineTube->ucs.axis_z*ucs.axis_z)>EPS_COS)
			return;	//端面图不添加检测线
		//1.添加钢管相贯检测线
		if(IsExistIntersectTube(pLineTube,pTower))
			return AppendIntersectTubeCheckLines(pLineTube,pTower);
		//2.添加钢管始终端端头和钢管中间的连接板之间的检测线(焊前检测线和焊后检测线)
		//2.1 查找需要添加检测线的钢板
		PLATESET PlateSet;	//统计Z轴方向与当前视图方向在一条直线上的钢板
		CLDSParamPlate *pStartParamPlate=NULL,*pEndParamPlate=NULL;
		pStartParamPlate=(CLDSParamPlate*)pTower->FromPartHandle(pLineTube->m_tJointStart.hLinkObj,CLS_PARAMPLATE);
		pEndParamPlate=(CLDSParamPlate*)pTower->FromPartHandle(pLineTube->m_tJointEnd.hLinkObj,CLS_PARAMPLATE);
		for(pPartItem=SonParts.GetFirst();pPartItem;pPartItem=SonParts.GetNext())
		{
			CLDSPlate *pPlate=(CLDSPlate*)pTower->FromPartHandle(pPartItem->hSonPart,CLS_PLATE);
			if(pPlate==NULL)
				continue;
			//排除十字插板附加钢板,避免重复添加检测线
			if(pStartParamPlate&&pStartParamPlate->m_iParamType==TYPE_XEND&&
				pStartParamPlate->IsInAttachPartList(pPlate->handle))
				continue;
			if(pEndParamPlate&&pEndParamPlate->m_iParamType==TYPE_XEND&&
				pEndParamPlate->IsInAttachPartList(pPlate->handle))
				continue;
			//cos0.5°= 0.99996192306417128873735516482698
			//double cosa=0.98480775301220805936674302458952;	//wht 10-08-15 使用EPS_COS精确度过高改为cos0.5°
			//生成视图时使用EPS_COS2判断是否共面，此处也应使用EPS_COS2判断,
			//否则会导致即未单独为某些钢板添加独立的视图，此处也未标注相关检测线 wht 11-07-18
			if(fabs(pPlate->ucs.axis_z*ucs.axis_z)>EPS_COS2)	//EPS_COS EPS_COS2 wht 10-04-20
				PlateSet.append(pPlate);
		}
		//2.2 遍历钢板集合查找并统计需要添加检测线的螺栓，并按上下侧分组
		//	  使用螺栓feature属性记录螺栓所在钢板句柄，同一钢板上的螺栓不用添加标注线
		BOLTSET upBoltSet;	//统计视图上侧需要添加检测线的螺栓
		BOLTSET downBoltSet;//统计视图下侧需要添加检测线的螺栓
		CLsRef *pLsRef=NULL;
		CLDSPlate *pPlate=NULL;
		UCS_STRU cs=ucs;
		cs.origin=pLineTube->Start();
		cs.axis_y=ucs.axis_z^pLineTube->ucs.axis_z;
		cs.axis_x=cs.axis_y^ucs.axis_z;
		normalize(cs.axis_x);
		normalize(cs.axis_y);
		for(pPlate=PlateSet.GetFirst();pPlate;pPlate=PlateSet.GetNext())
		{
			CLDSBolt *pUpMinXBolt=NULL, *pUpMaxXBolt=NULL;	//当前视图坐标系下一块钢板中X坐标最小/最大的螺栓
			CLDSBolt *pDownMinXBolt=NULL, *pDownMaxXBolt=NULL;	//当前视图坐标系下一块钢板中X坐标最小/最大的螺栓
			CMaxDouble max_x_up,max_x_down;
			CMinDouble min_x_up,min_x_down;
			for(pLsRef=pPlate->GetFirstLsRef();pLsRef;pLsRef=pPlate->GetNextLsRef())
			{
				f3dPoint ls_pos=pLsRef->GetLsPtr()->ucs.origin;
				coord_trans(ls_pos,cs,FALSE);
				if(ls_pos.y>0)
				{
					if(max_x_up.Update(ls_pos.x)==ls_pos.x)
						pUpMaxXBolt=pLsRef->GetLsPtr();
					if(min_x_up.Update(ls_pos.x)==ls_pos.x)
						pUpMinXBolt=pLsRef->GetLsPtr();
				}
				else if(ls_pos.y<0)
				{
					if(max_x_down.Update(ls_pos.x)==ls_pos.x)
						pDownMaxXBolt=pLsRef->GetLsPtr();
					if(min_x_down.Update(ls_pos.x)==ls_pos.x)
						pDownMinXBolt=pLsRef->GetLsPtr();
				}
			}
			if(pUpMinXBolt)	//用feature属性来表示两螺栓是否在同一钢板上
				pUpMinXBolt->feature=pPlate->handle;
			if(pUpMaxXBolt)	//用feature属性来表示两螺栓是否在同一钢板上
				pUpMaxXBolt->feature=pPlate->handle;
			if(pUpMaxXBolt==pUpMinXBolt)
				pUpMaxXBolt=NULL;
			if(pDownMinXBolt)	//用feature属性来表示两螺栓是否在同一钢板上
				pDownMinXBolt->feature=pPlate->handle;
			if(pDownMaxXBolt)	//用feature属性来表示两螺栓是否在同一钢板上
				pDownMaxXBolt->feature=pPlate->handle;
			if(pDownMaxXBolt==pDownMinXBolt)
				pDownMaxXBolt=NULL;
			CLDSBolt *pExistBolt=NULL;
			//将Y轴正方向的左右边缘螺栓插入到上侧检测线螺栓集合中
			for(pExistBolt=upBoltSet.GetFirst();pExistBolt;pExistBolt=upBoltSet.GetNext())
			{
				f3dPoint cur_ls_pos=pExistBolt->ucs.origin;
				coord_trans(cur_ls_pos,cs,FALSE);
				BOOL pushed=upBoltSet.push_stack();
				if(pUpMinXBolt!=NULL && pUpMinXBolt->handle!=pExistBolt->handle &&
					min_x_up.number<=cur_ls_pos.x)
				{
					upBoltSet.insert(pUpMinXBolt);
					pUpMinXBolt=NULL;	//已处理
				}
				upBoltSet.pop_stack(pushed);
				pushed=upBoltSet.push_stack();
				if(pUpMaxXBolt!=NULL && pUpMaxXBolt->handle!=pExistBolt->handle &&
					max_x_up.number<=cur_ls_pos.x)
				{
					upBoltSet.insert(pUpMaxXBolt);
					pUpMaxXBolt=NULL;	//已处理
				}
				upBoltSet.pop_stack(pushed);
				if(pUpMinXBolt==NULL && pUpMaxXBolt==NULL)
					break;
			}
			if(pExistBolt==NULL && pUpMinXBolt)
				upBoltSet.append(pUpMinXBolt);
			if(pExistBolt==NULL && pUpMaxXBolt)
				upBoltSet.append(pUpMaxXBolt);
			//将Y轴负方向的左右边缘螺栓插入到上侧检测线螺栓集合中
			for(pExistBolt=downBoltSet.GetFirst();pExistBolt;pExistBolt=downBoltSet.GetNext())
			{
				f3dPoint cur_ls_pos=pExistBolt->ucs.origin;
				coord_trans(cur_ls_pos,cs,FALSE);
				BOOL pushed=downBoltSet.push_stack();
				if(pDownMinXBolt!=NULL && pDownMinXBolt->handle!=pExistBolt->handle &&
					min_x_down.number<=cur_ls_pos.x)
				{
					downBoltSet.insert(pDownMinXBolt);
					pDownMinXBolt=NULL;	//已处理
				}
				downBoltSet.pop_stack(pushed);
				pushed=downBoltSet.push_stack();
				if(pDownMaxXBolt!=NULL && pDownMaxXBolt->handle!=pExistBolt->handle &&
					max_x_down.number<=cur_ls_pos.x)
				{
					downBoltSet.insert(pDownMaxXBolt);
					pDownMaxXBolt=NULL;	//已处理
				}
				downBoltSet.pop_stack(pushed);
				if(pDownMinXBolt==NULL && pDownMaxXBolt==NULL)
					break;
			}
			if(pExistBolt==NULL && pDownMinXBolt)
				downBoltSet.append(pDownMinXBolt);
			if(pExistBolt==NULL && pDownMaxXBolt)
				downBoltSet.append(pDownMaxXBolt);
		}
		//3.添加检测线
		//3.1 添加上侧检测线
		AddCheckLinesByBoltSet(this,pLineTube,upBoltSet,TRUE);
		//3.2 添加下侧检测线
		AddCheckLinesByBoltSet(this,pLineTube,downBoltSet,FALSE);
	}
	else if(pDatumPart->GetClassTypeId()==CLS_PLATE)
	{
		CLDSPart *pPart=NULL;
		CLDSPlate *pSonPlate=NULL;
		CLDSGroupLineAngle *pGroupLineAngle=NULL;
		CLDSPlate *pDatumPlate=(CLDSPlate*)pDatumPart;
		pPart=pTower->FromPartHandle(pDatumPlate->designInfo.m_hBasePart);
		if(pPart&&pPart->GetClassTypeId()==CLS_GROUPLINEANGLE)
		{	//为组合角钢填板添加默认的检测线
			pGroupLineAngle=(CLDSGroupLineAngle*)pPart;
			f3dPoint len_vec=pGroupLineAngle->Start()-pGroupLineAngle->End();
			normalize(len_vec);
			if(fabs(len_vec*ucs.axis_z)>EPS_COS2)
				return;	//端面图不需要检测线
			for(pPartItem=SonParts.GetFirst();pPartItem;pPartItem=SonParts.GetNext())
			{
				pSonPlate=(CLDSPlate*)pTower->FromPartHandle(pPartItem->hSonPart,CLS_PLATE);
				if(pSonPlate&&pSonPlate->designInfo.m_hBaseNode==pDatumPlate->designInfo.m_hBaseNode
					&&pSonPlate->designInfo.m_hBasePart==pDatumPlate->designInfo.m_hBasePart&&pSonPlate->handle!=pDatumPlate->handle)
					break;
			}
			if(pSonPlate)
			{	
				f3dPoint vec;
				double min_dist1=10000,min_dist2=10000;
				CLDSBolt *pBolt1=NULL,*pBolt2=NULL;
				for(CLsRef *pLsRef=pDatumPlate->GetFirstLsRef();pLsRef;pLsRef=pDatumPlate->GetNextLsRef())
				{
					vec=(*pLsRef)->ucs.origin-pSonPlate->ucs.origin;
					normalize(vec);
					if(vec*pSonPlate->ucs.axis_z>0)
					{
						f3dPoint base_pt=(*pLsRef)->ucs.origin;
						project_point(base_pt,pSonPlate->ucs.origin,pSonPlate->ucs.axis_z);
						double dist=DISTANCE((*pLsRef)->ucs.origin,base_pt);
						if(dist<min_dist1)
						{
							min_dist1=dist;
							pBolt1=pLsRef->GetLsPtr();
						}
					}
					else 
					{
						f3dPoint base_pt=(*pLsRef)->ucs.origin;
						project_point(base_pt,pSonPlate->ucs.origin,-pSonPlate->ucs.axis_z);
						double dist=DISTANCE((*pLsRef)->ucs.origin,base_pt);
						if(dist<min_dist2)
						{
							min_dist2=dist;
							pBolt2=pLsRef->GetLsPtr();
						}
					}
				}
				if(pBolt1)
				{
					pCheckLine= CheckLines.append();
					pCheckLine->m_bBeforeWeld=TRUE;
					pCheckLine->m_hStartPart=pBolt1->handle;
					pCheckLine->m_hEndPart=pSonPlate->handle;
				}
				if(pBolt2)
				{
					pCheckLine= CheckLines.append();
					pCheckLine->m_bBeforeWeld=TRUE;
					pCheckLine->m_hStartPart=pBolt2->handle;
					pCheckLine->m_hEndPart=pSonPlate->handle;
				}
			}
		}
	}
}

//根据视图类型查找当前视图描述的主构件
CLDSPart *CSectionView::GetMainPartHandle(IModel *pModel)
{
	PART_ITEM *pItem=NULL;
	//一个视图可能描述多块指定类型的构件 如上、下封板
	//取舍依据:将构件原点转换到视图坐标系下取Z坐标较大的构件为主构件
	CLDSPart *pPrevPart=NULL,*pMainPart=NULL; 
	for(pItem=SonParts.GetFirst();pItem;pItem=SonParts.GetNext())
	{
		CLDSPart *pPart=pModel->FromPartHandle(pItem->hSonPart);
		if(pPart==NULL)
			continue;
		if(pPart->GetClassTypeId()==CLS_PARAMPLATE)
		{
			CLDSParamPlate *pParamPlate=(CLDSParamPlate*)pPart;
			if((m_iViewType==VIEW_CIRCOVERPLATE&&pParamPlate->m_iParamType==TYPE_CIRCOVERPLATE)//封板视图
				||(m_iViewType==VIEW_CIRRIBPLATE&&pParamPlate->m_iParamType==TYPE_CIRRIBPLATE)//肋板视图
				||(m_iViewType==VIEW_TUBERIBPLATE&&pParamPlate->m_iParamType==TYPE_TUBERIBPLATE)//跨越钢管连板视图
				||(m_iViewType==VIEW_FL&&(pParamPlate->IsFL()))	//法兰视图
				||(m_iViewType==VIEW_INSERTPLATE&&(pParamPlate->IsInsertPlate())))//插板视图
			{
				if(pMainPart)
				{	//将构件原点转换到视图坐标系下取Z坐标较大的构件为主构件
					f3dPoint main_pos=pMainPart->ucs.origin;
					f3dPoint cur_pos=pPart->ucs.origin;
					coord_trans(main_pos,ucs,FALSE);
					coord_trans(cur_pos,ucs,FALSE);
					if (main_pos.z<cur_pos.z)
						pMainPart=pPart;
				}
				else 
					pMainPart=pPart;
			}
		}
		else if(pPart->GetClassTypeId()==CLS_PLATE)
		{
			CLDSPlate *pPlate=(CLDSPlate*)pPart;
			if((m_iViewType==VIEW_NODEPLATE&&pPlate->designInfo.m_hBaseNode>0x20)
				||(m_iViewType==VIEW_CIRPLATE&&pPlate->m_fInnerRadius>0))
				pMainPart=pPart;
		}
		else if(pPart->IsLinePart())
		{
			if((m_iViewType==VIEW_FOOTNAILANGLE&&pPart->GetClassTypeId()==CLS_LINESLOT)
				||(m_iViewType==VIEW_FOOTNAILSLOT&&pPart->GetClassTypeId()==CLS_LINEANGLE))
				pMainPart=pPart;
		}
	}
	return pMainPart;
}

//添加指定构件到当前视图构件链表	wht 10-08-10
CSectionView::PART_ITEM *CSectionView::AddPart(long hSonPart,CLDSPart *pSonPart/*=NULL*/,int cFlag/*=0*/)
{
	CSectionView::PART_ITEM *pPartItem = NULL;
	if(pSonPart)
		hSonPart=pSonPart->handle;
	pPartItem = SonParts.Add(hSonPart);
	pPartItem->cFlag = cFlag;
	LoadTagInfo(pPartItem)->pCurPart = pSonPart;
	return pPartItem;
}
void CSectionView::ToBuffer(CBuffer &buffer,long version/*=0*/,long doc_type/*=0*/)
{
	buffer.WriteString(sName);
	buffer.WriteInteger(m_bLocked);	//锁定视图
	buffer.WriteInteger(m_iViewType);//视图类型
	buffer.WriteInteger(index);		//视图索引
	buffer.WritePoint(ucs.origin);
	buffer.WritePoint(ucs.axis_x);
	buffer.WritePoint(ucs.axis_y);
	buffer.WritePoint(ucs.axis_z);
	if( version==0||
		(doc_type==1&&version>=4010200)||
		(doc_type==2&&version>=4010200)||
		(doc_type==4&&version>=1020003)||
		(doc_type==5&&version>=1020003))
		des_cs.ToBuffer(buffer,version,doc_type);
	buffer.WriteInteger(SonParts.GetNodeNum());
	for(CSectionView::PART_ITEM *pItem=SonParts.GetFirst();pItem;pItem=SonParts.GetNext())
	{
		buffer.WriteInteger(pItem->hSonPart);
		buffer.WriteByte(pItem->cFlag);
		if( version==0||
		(doc_type==1&&version>=4010200)||
		(doc_type==2&&version>=1010200)||
		(doc_type==4&&version>=1020101)||
		(doc_type==5&&version>=1020101))
			buffer.WriteInteger(pItem->iResidePlaneNo);
	}
	buffer.WriteInteger(LocatePoints.GetNodeNum());
	for(CPartGroupLocatePoint *pLocatePoint=LocatePoints.GetFirst();pLocatePoint;pLocatePoint=LocatePoints.GetNext())
	{
		pLocatePoint->ToBuffer(buffer,version,doc_type);
	}
	buffer.WriteInteger(CheckLines.GetNodeNum());
	for(CCheckLineDimension *pCheckLine=CheckLines.GetFirst();pCheckLine;pCheckLine=CheckLines.GetNext())
	{
		pCheckLine->ToBuffer(buffer,version,doc_type);
	}
	buffer.WriteInteger(Angulars.GetNodeNum());
	for(CAngularDimension *pAngular=Angulars.GetFirst();pAngular;pAngular=Angulars.GetNext())
	{
		pAngular->ToBuffer(buffer,version,doc_type);
	}
	if( version==0||
	(doc_type==1&&version>=4010200)||
	(doc_type==2&&version>=1010200)||
	(doc_type==4&&version>=1020101)||
	(doc_type==5&&version>=1020101))
	{
		buffer.WriteInteger(hashAssistPlanes.GetNodeNum());
		for(CDrawingAssistant* pAssist=hashAssistPlanes.GetFirst();pAssist;pAssist=hashAssistPlanes.GetNext())
			pAssist->ToBuffer(buffer,version,doc_type);
	}
}

void CSectionView::ToXmlFile(FILE* fp,DWORD schema)
{
	char sText[500]="";
	fprintf(fp,"<视图信息 sName=\"%s\">\n",sName);
	if(m_bLocked==1)
		strcpy(sText,"true");
	else 
		strcpy(sText,"false");
	fprintf(fp,"<锁定视图 bLocked=\"%s\"/>\n",sText);
	fprintf(fp,"<视图类型 m_iViewType=\"%d\"/>\n",m_iViewType);
	fprintf(fp,"<视图索引 index=\"%d\"/>\n",index);
	fprintf(fp,"<原点坐标 origin=\"(%.3f,%.3f,%.3f)\"/>\n",ucs.origin.x,ucs.origin.y,ucs.origin.z);
	fprintf(fp,"<X轴坐标 axis_x=\"(%.3f,%.3f,%.3f)\"/>\n",ucs.axis_x.x,ucs.axis_x.y,ucs.axis_x.z);
	fprintf(fp,"<Y轴坐标 axis_y=\"(%.3f,%.3f,%.3f)\"/>\n",ucs.axis_y.x,ucs.axis_y.y,ucs.axis_y.z);
	fprintf(fp,"<Z轴坐标 axis_z=\"(%.3f,%.3f,%.3f)\"/>\n",ucs.axis_z.x,ucs.axis_z.y,ucs.axis_z.z);
	des_cs.ToXmlFile(fp,schema);
	fprintf(fp,"<子构件数量 SonPartsNum=\"%d\"/>\n",SonParts.GetNodeNum());
	for(CSectionView::PART_ITEM *pItem=SonParts.GetFirst();pItem;pItem=SonParts.GetNext())
		fprintf(fp,"<子构件信息 handle=\"0x%x\" Flag=\"%c\"/>\n",pItem->hSonPart,pItem->cFlag);
	fprintf(fp,"<LocatePoint num=\"%d\"/>\n",LocatePoints.GetNodeNum());
	for(CPartGroupLocatePoint *pLocatePoint=LocatePoints.GetFirst();pLocatePoint;pLocatePoint=LocatePoints.GetNext())
		pLocatePoint->ToXmlFile(fp,schema);
	fprintf(fp,"<CheckLines num=\"%d\"/>\n",CheckLines.GetNodeNum());
	for(CCheckLineDimension *pCheckLine=CheckLines.GetFirst();pCheckLine;pCheckLine=CheckLines.GetNext())
		pCheckLine->ToXmlFile(fp,schema);
	fprintf(fp,"<Angulars num=\"%d\"/>\n",Angulars.GetNodeNum());
	for(CAngularDimension *pAngular=Angulars.GetFirst();pAngular;pAngular=Angulars.GetNext())
		pAngular->ToXmlFile(fp,schema);
	fprintf(fp,"</视图信息>\n");
}
void CSectionView::FromBuffer(CBuffer &buffer,long version/*=NULL*/,long doc_type/*=0*/)
{
	if(doc_type==0)
		doc_type=PRODUCT_TYPE;
	buffer.ReadString(sName);
	buffer.ReadInteger(&m_bLocked);	//锁定视图
	/*#ifdef HAICHENGYINFENG	//海城银烽特殊需要塔脚板折叠板等
	#if defined(__TMA_FILE_)||defined(__TMA_)
	if(version==0||version>=4000024)//version!=NULL&&compareVersion(version,"4.0.0.24")>=0)
	#elif defined(__LMA_FILE_)||defined(__LMA_)
	if(version==0||version>=1000078)//version!=NULL&&compareVersion(version,"1.0.0.78")>=0)
	#else
	if(version==0||version>=1000006)//version!=NULL&&compareVersion(version,"1.0.0.6")>=0)
	#endif
	#else*/
	/*#if defined(__TMA_FILE_)||defined(__TMA_)
	if(version==0||version>=4000024)//version!=NULL&&compareVersion(version,"4.0.0.24")>=0)
	#elif defined(__LMA_FILE_)||defined(__LMA_)
	if(version==0||version>=1000079)//version!=NULL&&compareVersion(version,"1.0.0.79")>=0)
	#elif defined(__TDA_FILE_)
	if(version==0||version>=1000001)
	#else
	if(version==0||version>=1000006)//version!=NULL&&compareVersion(version,"1.0.0.6")>=0)
	#endif*/
	//#endif
	if( version==0||((doc_type==1&&version>=4000024)||
		(doc_type==2&&version>=1000079)||(doc_type==4&&version>=1000006)||doc_type==5))
	{	//视图类型
		int iType=0;
		buffer.ReadInteger(&iType);
		if(iType==1)
			m_iViewType=VIEW_MAIN;
		else if(iType==2)
			m_iViewType=VIEW_FRONT;
		else if(iType==3)
			m_iViewType=VIEW_NODEPLATE;
		else if(iType==4)
			m_iViewType=VIEW_CIRCOVERPLATE;
		else if(iType==5)
			m_iViewType=VIEW_CIRRIBPLATE;
		else if(iType==6)
			m_iViewType=VIEW_TUBERIBPLATE;
		else if(iType==7)
			m_iViewType=VIEW_FL;
		else if(iType==8)
			m_iViewType=VIEW_CIRPLATE;
		else if(iType==9)
			m_iViewType=VIEW_INSERTPLATE;
		else if(iType==10)
			m_iViewType=VIEW_FOOTNAILANGLE;
		else if(iType==11)
			m_iViewType=VIEW_FOOTNAILSLOT;
		else if(iType==12)
			m_iViewType=VIEW_FOOT;
		else if(iType==13)
			m_iViewType=VIEW_JOINSECTION;
		else if(iType==14)	//对接钢管简图
			m_iViewType=VIEW_JOINTTUBE;
		else if(iType==15)	//K节点相贯简图
			m_iViewType=VIEW_KNODESKETCH;
		else
			m_iViewType=VIEW_USERDEF;
		buffer.ReadInteger(&index);
	}
	buffer.ReadPoint(ucs.origin);
	buffer.ReadPoint(ucs.axis_x);
	buffer.ReadPoint(ucs.axis_y);
	buffer.ReadPoint(ucs.axis_z);
	if( version==0||
		(doc_type==1&&version>=4010200)||
		(doc_type==2&&version>=1010200)||
		(doc_type==4&&version>=1020003)||
		(doc_type==5&&version>=1020003))
	{
		des_cs.FromBuffer(buffer,version,doc_type);
	}
	else
	{
		CParaCS::PARAMETRIC_INFO param=des_cs.GetParamInfo();
		param.desOrg.datum_pos_style=0;
		param.desOrg.datum_pos=ucs.origin;
		param.desAxisX.norm_style=0;
		param.desAxisX.vector=ucs.axis_x;
		param.desAxisY.norm_style=0;
		param.desAxisY.vector=ucs.axis_y;
		param.desAxisZ.norm_style=0;
		param.desAxisZ.vector=ucs.axis_z;
		des_cs.SetParamInfo(param);
	}
	int j,nn;
	buffer.ReadInteger(&nn);
	for(j=0;j<nn;j++)
	{
		long hSonPart=0;
		buffer.ReadInteger(&hSonPart);
		CSectionView::PART_ITEM *pItem,item;
		if(hSonPart<=0)
		{
			logerr.Log("组焊件中存在零句柄子项构件！");
			pItem=&item;
		}
		else
			pItem=SonParts.Add(hSonPart);
		buffer.ReadByte(&pItem->cFlag);
		if( version==0||
		(doc_type==1&&version>=4010200)||
		(doc_type==2&&version>=1010200)||
		(doc_type==4&&version>=1020101)||
		(doc_type==5&&version>=1020101))
			buffer.ReadInteger(&pItem->iResidePlaneNo);
	}
	buffer.ReadInteger(&nn);
	for(j=0;j<nn;j++)
	{
		CPartGroupLocatePoint *pLocatePoint=LocatePoints.append();
		pLocatePoint->FromBuffer(buffer,version);
	}
	buffer.ReadInteger(&nn);
	for(j=0;j<nn;j++)
	{
		CCheckLineDimension *pCheckLine=CheckLines.append();
		pCheckLine->FromBuffer(buffer,version);
	}
	buffer.ReadInteger(&nn);
	for(j=0;j<nn;j++)
	{
		CAngularDimension *pAngular=Angulars.append();
		pAngular->FromBuffer(buffer,version);
	}
	if( version==0||
		(doc_type==1&&version>=4010200)||
		(doc_type==2&&version>=1010200)||
		(doc_type==4&&version>=1020101)||
		(doc_type==5&&version>=1020101))
	{
		buffer.ReadInteger(&nn);
		for(j=0;j<nn;j++)
		{
			CDrawingAssistant* pAssist=hashAssistPlanes.Add(0);
			pAssist->FromBuffer(buffer,version);
			hashAssistPlanes.ModifyKeyId(hashAssistPlanes.GetCursorKey(),pAssist->iNo);
		}
	}
	LocatePoints.Empty();//不存储,只在出图时临时生成,否则这部分代码修改后,必须在设计环境下重新统计组焊件
	CheckLines.Empty();	//不存储,只在出图时临时生成,否则这部分代码修改后,必须在设计环境下重新统计组焊件
	Angulars.Empty();	//不存储,只在出图时临时生成,否则这部分代码修改后,必须在设计环境下重新统计组焊件
}

void CSectionView::CopyProperty(CSectionView *pSrcView)
{
	if(pSrcView==NULL)
		return;
	strcpy(sName,pSrcView->sName);
	des_cs=pSrcView->des_cs;
	ucs=pSrcView->ucs;
	m_iViewType=pSrcView->m_iViewType;
	m_bLocked=pSrcView->m_bLocked;
	SonParts.Empty();
	for(PART_ITEM *pItem=pSrcView->SonParts.GetFirst();pItem;pItem=pSrcView->SonParts.GetNext())
		SonParts.SetValue(pItem->hSonPart,*pItem);
}
UCS_STRU CSectionView::UpdateUCS(IModel *pModel,CLDSPartGroup *pPartGroup)
{
	des_cs.SetModifiedState();
	if(des_cs.UpdateACS(pModel))
		ucs=des_cs.GetACS();
	else 
	{
		CXhChar100 sGroupName;
		if(pPartGroup)
			sGroupName.Copy(pPartGroup->sGroupName);
		logerr.Log("【%s】组焊件【%s】视图坐标系计算错误！",(char*)sGroupName,sName);
	}
	return ucs;
}
int CSectionView::SmartFilterNeedDrawParts(IModel *pModel,PARTSET& partset)
{
	CSectionView::PART_ITEM* pItem;
	if(m_iViewType!=VIEW_MAIN && m_iViewType!=VIEW_FRONT)
	{
		for(pItem=SonParts.GetFirst();pItem;pItem=SonParts.GetNext())
		{
			if(TagPart(pItem)==NULL)
				LoadTagInfo(pItem)->pCurPart=pModel->FromPartHandle(pItem->hSonPart);
			if(TagPart(pItem))
				partset.append(TagPart(pItem));
		}
		return partset.GetNodeNum();	//目前暂仅支持在钢管主视图中筛选过滤出需要绘制的构件
	}
	CParaCS::PARAMETRIC_INFO paramcs=des_cs.GetParamInfo();
	CLDSLineTube *pLineTube=NULL;
	if(paramcs.desAxisX.norm_style==5)
		pLineTube=(CLDSLineTube*)pModel->FromPartHandle(paramcs.desAxisX.hVicePart,CLS_LINETUBE);
	else if(paramcs.desAxisX.norm_style==0)	//自定义X轴基准方向
	{
		for(pItem=SonParts.GetFirst();pItem;pItem=SonParts.GetNext())
		{
			if(TagPart(pItem)==NULL)
				LoadTagInfo(pItem)->pCurPart=pModel->FromPartHandle(pItem->hSonPart);
			if(TagPart(pItem)&&TagPart(pItem)->GetClassTypeId()==CLS_LINETUBE)
			{
				pLineTube=(CLDSLineTube*)TagPart(pItem);
				f3dPoint axis_x=pLineTube->End()-pLineTube->Start();
				normalize(axis_x);
				if(fabs(ucs.axis_x*axis_x)>EPS_COS2)
					break;
				pLineTube=NULL;
			}
		}
	}
	if(pLineTube==NULL)
	{
		for(pItem=SonParts.GetFirst();pItem;pItem=SonParts.GetNext())
		{
			if(TagPart(pItem)!=NULL)
				partset.append(TagPart(pItem));
		}
		return partset.GetNodeNum();	//无法提取出X轴基准钢管
	}
	CSuperSmartPtr<CLDSPart> pStartPlate=pModel->FromPartHandle(pLineTube->m_tJointStart.hLinkObj);
	CSuperSmartPtr<CLDSPart> pEndPlate  =pModel->FromPartHandle(pLineTube->m_tJointEnd.hLinkObj);
	SCOPE_STRU draw_space;	//当前视图绘图坐标系下
	f3dLine axisline(pLineTube->Start(),pLineTube->End());
	des_cs.UpdateACS(pModel);
	GECS acs=des_cs.GetACS();
	axisline.startPt=acs.TransPToCS(axisline.startPt);
	axisline.endPt=acs.TransPToCS(axisline.endPt);
	draw_space.VerifyVertex(axisline.startPt);
	draw_space.VerifyVertex(axisline.endPt);
	double radius=pLineTube->GetWidth()*0.5;
	draw_space.fMinY-=radius;
	draw_space.fMaxY+=radius;
	draw_space.fMinZ-=radius;
	draw_space.fMaxZ+=radius;
	double justify;
	//1.提取该视图中需要绘制的杆件
	CHashSet<CLDSLinePart*> hashRodSet;
	CHashList<long> hashEndPlates;
	for(pItem=SonParts.GetFirst();pItem;pItem=SonParts.GetNext())
	{
		CSuperSmartPtr<CLDSPart> pCurPart=LoadTagInfo(pItem)->pCurPart=pModel->FromPartHandle(pItem->hSonPart);
		if(pCurPart.IsNULL())
			continue;
		pCurPart->feature=0;
		if(!pCurPart->IsLinePart())
			continue;
		f3dLine rayline(pCurPart.LinePartPointer()->Start(),pCurPart.LinePartPointer()->End());
		f3dPoint rayvec=rayline.endPt-rayline.startPt;
		normalize(rayvec);
		rayline.startPt-=rayvec*pCurPart.LinePartPointer()->startOdd();
		rayline.endPt  +=rayvec*pCurPart.LinePartPointer()->endOdd();
		rayline.startPt = acs.TransPToCS(rayline.startPt);
		rayline.endPt = acs.TransPToCS(rayline.endPt);
		if( pCurPart!=pLineTube&&
			rayline.startPt.z<axisline.startPt.z+EPS&&rayline.endPt.z<axisline.startPt.z+EPS&&
			rayline.startPt.y<draw_space.fMaxY&&rayline.startPt.y>draw_space.fMinY&&
			rayline.endPt.y<draw_space.fMaxY&&rayline.endPt.y>draw_space.fMinY)
		{
			pCurPart->feature=1;
			continue;	//当前绘制杆件被基准主管挡在后面时，不绘制
		}
		partset.append(pCurPart);
		pCurPart->feature=1;	//已处理
		hashRodSet.SetValue(pCurPart->handle,pCurPart.LinePartPointer());
		if(pCurPart->GetClassTypeId()==CLS_LINETUBE)
		{
			//由于过往旧数据中m_tJointStart.type值存在错误，暂不使用该条件过滤 wjh-2014.3.30
			//if(pCurPart.LineTubePointer()->m_tJointStart.type>=2)
				hashEndPlates.Add(pCurPart.LineTubePointer()->m_tJointStart.hLinkObj);
			//if(pCurPart.LineTubePointer()->m_tJointEnd.type>=2)
				hashEndPlates.Add(pCurPart.LineTubePointer()->m_tJointEnd.hLinkObj);
		}
	}
	//2.提取该视图中需要绘制的法兰及端板
	for(pItem=SonParts.GetFirst();pItem;pItem=SonParts.GetNext())
	{
		if(TagPart(pItem)==NULL)
			continue;
		CSuperSmartPtr<CLDSPart> pCurPart=TagPart(pItem);
		if(pCurPart->feature!=0)
			continue;	//已筛选过的构件
		if(pCurPart->GetClassTypeId()!=CLS_PARAMPLATE ||
			(!pCurPart.ParamPlatePointer()->IsFL()&&!pCurPart.ParamPlatePointer()->IsInsertPlate()))
			continue;	//不是端板类型(法兰及插板)的参数化板
		pCurPart->feature=1;
		if(hashEndPlates.GetValue(pCurPart->handle)==NULL)
			continue;	//端板所依附的杆件不绘制该端板自然也不绘制
		if(pCurPart.ParamPlatePointer()->IsInsertPlate())
		{
			partset.append(pCurPart);
			continue;
		}
		justify=fabs(pCurPart->ucs.axis_z*acs.axis_z);
		if((m_iViewType==VIEW_MAIN||m_iViewType==VIEW_FRONT)&&justify>0.707)//EPS_COS2)
			continue;	//主视图中只绘制竖直方向的法兰(或底脚板)
		partset.append(pCurPart);
	}
	//3.筛选过滤法兰肘板
	for(pItem=SonParts.GetFirst();pItem;pItem=SonParts.GetNext())
	{
		if(TagPart(pItem)==NULL)
			continue;
		CSuperSmartPtr<CLDSPart> pCurPart=TagPart(pItem);
		if(pCurPart->feature!=0)
			continue;	//已筛选过的构件
		if(  pCurPart->GetClassTypeId()!=CLS_PARAMPLATE ||	//由于历史原因法兰上的加劲板有时是TYPE_ELBOWPLATE(早期)，有时是TYPE_RIBPLATE
			(pCurPart.ParamPlatePointer()->m_iParamType!=TYPE_ELBOWPLATE&&pCurPart.ParamPlatePointer()->m_iParamType!=TYPE_RIBPLATE))
			continue;
		long hDatumTube=0,hDatumPlate=0;
		char cDatumTube='K',cDatumPlate='L';
		if(pCurPart.ParamPlatePointer()->m_iParamType==TYPE_RIBPLATE)
		{
			cDatumTube='A';
			cDatumPlate='C';
		}
		pCurPart.ParamPlatePointer()->GetDesignItemValue(cDatumTube,&hDatumTube);
		pCurPart.ParamPlatePointer()->GetDesignItemValue(cDatumPlate,&hDatumPlate);
		pCurPart->feature=1;	//已进行筛选处理
		if(hashEndPlates.GetValue(abs(hDatumPlate))==NULL)
			continue;
		CLDSLineTube* pDatumTube=(CLDSLineTube*)pModel->FromPartHandle(abs(hDatumTube),CLS_LINETUBE);
		justify=fabs(pCurPart->ucs.axis_z*acs.axis_z);
		if(justify<EPS2 || justify>EPS_COS2)
		{
			if(pDatumTube && !pDatumTube->IsCanHide(pCurPart,acs.axis_z))	//潜在下面的肋（肘）板不绘制
				partset.append(pCurPart);	//由于法兰肘板可在法兰图中描述，固须较为严格的与当前绘图平面平行或垂直才绘制(但也不能用EPS,EPS_COS判别)
		}
	}
	//4.筛选过滤其余普通钢板
	for(pItem=SonParts.GetFirst();pItem;pItem=SonParts.GetNext())
	{
		if(TagPart(pItem)==NULL)
			continue;
		CSuperSmartPtr<CLDSPart> pCurPart=TagPart(pItem);
		if(pCurPart->feature!=0)
			continue;	//已筛选过的构件
		if(!pCurPart->IsPlate())
			continue;
		pCurPart->Create3dSolidModel();
		bool bUnderlyingPlate=true,bTopFloatPlate=true;
		for(int i=0;i<pCurPart->pSolidBody->KeyPointNum();i++)
		{
			GEPOINT vertice=pCurPart->pSolidBody->GetKeyPointAt(i);
			vertice=acs.TransPToCS(vertice);
			if(bUnderlyingPlate&&vertice.z>axisline.startPt.z||fabs(vertice.y)>radius)
				bUnderlyingPlate=false;	//有一个点不在主管轴线之下，则表示钢板不位于绘图平面的背面
			if(bTopFloatPlate&&vertice.z<axisline.startPt.z+radius+10)
				bTopFloatPlate=false;//有一个点不漂浮于主管外壁之上，则表示该板不是漂浮板
			if(!bUnderlyingPlate&&!bTopFloatPlate)
				break;
		}
		pCurPart->feature=1;	//已进行筛选处理
		if(bUnderlyingPlate || bTopFloatPlate)
			continue;
		partset.append(pCurPart);
	}
	return partset.GetNodeNum();
}
//
CSlaveSectionView::CSlaveSectionView(int id) : CSectionView(id)
{
	m_idViewType=CLS_SLAVE_VIEW;
	m_idHostView=0;
	direction.Set(1,0,0);
	direct_offset=0;	//剖面图符实际标注位置与定位点间沿视线方向的偏移距离
	symbol_dist=10;		//剖面图符(成对)间的距离
	symbol.Copy("");	//剖面图符上的标注文字
}
void CSlaveSectionView::ToBuffer(CBuffer &buffer,long version,long doc_type/* =0 */)
{
	CSectionView::ToBuffer(buffer,version,doc_type);
	if(version==0||
		(doc_type==1&&version>=4010200)||
		(doc_type==2&&version>=1010200)||
		(doc_type==4&&version>=1020102)||
		(doc_type==5&&version>=1020102))
	{
		buffer.WriteInteger(m_idHostView);
		buffer.WritePoint(location);
		buffer.WritePoint(direction);
		buffer.WriteDouble(direct_offset);
		buffer.WriteDouble(symbol_dist);
		buffer.WriteString(symbol);
	}
}
void CSlaveSectionView::FromBuffer(CBuffer &buffer,long version/* =NULL */,long doc_type/* =0 */)
{
	CSectionView::FromBuffer(buffer,version,doc_type);
	if(version==0||
		(doc_type==1&&version>=4010200)||
		(doc_type==2&&version>=1010200)||
		(doc_type==4&&version>=1020102)||
		(doc_type==5&&version>=1020102))
	{
		buffer.ReadInteger(&m_idHostView);
		buffer.ReadPoint(location);
		buffer.ReadPoint(direction);
		buffer.ReadDouble(&direct_offset);
		buffer.ReadDouble(&symbol_dist);
		buffer.ReadString(symbol,symbol.LengthMax()+1);
	}
}
//计算法兰半径
static double GetFlR(CLDSParamPlate *pPlate)
{
	if(pPlate==NULL||!pPlate->IsFL())
		return 0;
	double R=0;
	if(pPlate->m_iParamType==TYPE_FL)
	{
		pPlate->GetDesignItemValue('W',&R);
		R*=0.5;
	}
	else if(pPlate->m_bStdPart)
	{
		CLDSStdPartModel stdPartModel;
		if(pPlate->GetStdPartModel(&stdPartModel))
		{
			if(pPlate->m_iParamType==TYPE_FLD||pPlate->m_iParamType==TYPE_FLP)
				R=stdPartModel.param.fl_param.D*0.5;		//对/平焊法兰
			else if(pPlate->m_iParamType==TYPE_FLG||pPlate->m_iParamType==TYPE_FLR)
				R=stdPartModel.param.fl_param2.fOuterD*0.5;	//刚/柔性法兰
		}
	}
	return R;
}
void CSlaveSectionView::InitSlaveSectionView(CSectionView *pHostView,IModel *pModel)
{
	if(pHostView==NULL)
		return;
	m_idHostView=pHostView->GetId();
	KEY2C keySymbol=BelongPartGroup()->GetIdleSectSymbol();
	symbol.Copy(keySymbol.Label());
	const int SYMBOL_OFFSET_DIST=10;	//标注点沿标注负方向的偏移距离
	//查找端面图主构件
	CLDSPart *pMainPart=GetMainPartHandle(pModel);
	if(pMainPart)
	{
		CLDSPart *pFatherPart=pModel->FromPartHandle(pMainPart->m_hPartWeldParent);
		if(pFatherPart==NULL)
			return;
		//1.剖视图符方向、标注位置、剖视图宽度初始值
		direction=-ucs.axis_z;
		location=pMainPart->ucs.origin;
		symbol_dist=1.2*pMainPart->GetWidth();			//偏移距离初始值为1.2*主构件宽度
		direct_offset=SYMBOL_OFFSET_DIST;
		//2.父构件为杆件时更新剖视图符参数
		if(pFatherPart->IsLinePart())
		{	
			symbol_dist=0.5*pFatherPart->GetWidth();
			if(pMainPart->GetClassTypeId()==CLS_PARAMPLATE)
			{
				CLDSParamPlate *pMainParamPlate=(CLDSParamPlate*)pMainPart;
				if(pMainParamPlate->IsInsertPlate())
				{
					double L=0;
					pMainParamPlate->GetDesignItemValue('L',&L);
					if(ucs.axis_z*pMainParamPlate->ucs.axis_x>0)
						location+=ucs.axis_z*L;
					else
						location-=ucs.axis_z*L;
				}
				symbol_dist=max(symbol_dist,GetFlR((CLDSParamPlate*)pMainPart));

			}
			//主构件焊接父构件为杆件，且杆件方向与端面图Z轴方向共线
			CLDSLinePart *pLinePart=(CLDSLinePart*)pFatherPart;
			f3dPoint len_vec=pLinePart->End()-pLinePart->Start();
			normalize(len_vec);
			if(fabs(len_vec*direction)>EPS_COS2)
			{
				f3dPoint perp_pos=location;
				SnapPerp(&perp_pos,pLinePart->Start(),pLinePart->End(),location);
				location=perp_pos;
			}
		}
		//3.将剖视图符方向及标注位置转换到宿主视图坐标系下
		//绘图模块中视图坐标系需进行调整，所以在这儿不进行坐标转换__wxc 2014.8.14
		//vector_trans(direction,pHostView->ucs,FALSE);	//转换到宿主视图坐标系下
		//coord_trans(location,pHostView->ucs,FALSE);
	}
}

int CSlaveSectionView::GetPropValueStr(long id,char* valueStr)
{
	int nRetCode=CSectionView::GetPropValueStr(id,valueStr);
	if(nRetCode>0)
		return nRetCode;
	//
	CXhChar100 sText;
	if(GetPropID("m_idHostView")==id)
	{
		if(m_pPartGroup)
		{
			CSectionView *pHostView=m_pPartGroup->SonViews.GetValue(m_idHostView);
			if(pHostView)
				sText.Printf("%s(Id:%d)",pHostView->sName,pHostView->GetId());
		}
	}
	else if(GetPropID("location")==id)		//宿主视图绘图坐标系下的剖面图符定位点坐标
		sText.ConvertFromPoint(location);
	else if(GetPropID("location.x")==id)
	{
		sText.Printf("%f",location.x);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("location.y")==id)
	{
		sText.Printf("%f",location.y);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("location.z")==id)
	{
		sText.Printf("%f",location.z);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("direction")==id)		//宿主视图绘图坐标系下的剖面图符视线方向
		sText.ConvertFromPoint(direction);
	else if(GetPropID("direction.x")==id)
	{
		sText.Printf("%f",direction.x);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("direction.y")==id)
	{
		sText.Printf("%f",direction.y);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("direction.z")==id)
	{
		sText.Printf("%f",direction.z);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("direct_offset")==id)	//剖面图符实际标注位置与定位点间沿视线方向的偏移距离
	{
		sText.Printf("%f",direct_offset);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("symbol_dist")==id)	//剖面图符(成对)间的距离
	{
		sText.Printf("%f",symbol_dist);
		SimplifiedNumString(sText);
	}
	else if(GetPropID("symbol")==id)		//剖面图符上的标注文字
		sText.Copy(symbol);
	if(valueStr)
		strcpy(valueStr,sText);
	return strlen(sText);
}
////////////////////////////////////////////////////////////////////////////////
//CLDSPartGroup
////////////////////////////////////////////////////////////////////////////////
static CSectionView* CreateSectionView(int iViewType,DWORD key,void* pContext)
{
	CSectionView *pView=NULL;
	switch(iViewType)
	{
	case CSectionView::CLS_BASIC_VIEW:
		pView = new CSectionView(key);
		break;
	case CSectionView::CLS_SLAVE_VIEW:
		pView = new CSlaveSectionView(key);
		break;
	default:
		pView = new CSectionView(key);
	}
	pView->SetBelongPartGroup((CLDSPartGroup*)pContext);
	//memcpy(&pView->GetViewClsType(),&iViewType,4);
	return pView;
}
static BOOL DestroyView(CSectionView* pView)
{
	switch(pView->GetViewTypeId())
	{
	case CSectionView::CLS_BASIC_VIEW:
		delete pView;
		break;
	case CSectionView::CLS_SLAVE_VIEW:
		delete (CSlaveSectionView*)pView;
		break;
	default:
		delete pView;
	}
	return TRUE;
}
CLDSPartGroup::CLDSPartGroup()
{
	handle=m_uStatMatCoef=0;
	strcpy(sFolderName,"");
	strcpy(sGroupName,"");
	m_uStatMatCoef=1;
	m_iPartGroupType=0;
	m_bFootPartGroup=FALSE;
	SonViews.m_pContext = this;
	SonViews.CreateNewAtom=CreateSectionView;
	SonViews.DeleteAtom=DestroyView;
}
void CLDSPartGroup::ToBuffer(CBuffer &buffer,long version/*=0*/,long doc_type/*=0*/)
{
	buffer.WriteInteger(handle);
	buffer.WriteString(sFolderName);
	buffer.WriteString(sGroupName);
	buffer.WriteDword(m_uStatMatCoef);
	buffer.WritePoint(ucs.origin);
	buffer.WritePoint(ucs.axis_x);
	buffer.WritePoint(ucs.axis_y);
	buffer.WritePoint(ucs.axis_z);
	buffer.WriteInteger(m_iPartGroupType);	//标准组焊件
	buffer.WriteInteger(m_bFootPartGroup);	//塔脚板组焊件 wht 10-01-14
	buffer.WriteInteger(SonViews.GetNodeNum());
	for(CSectionView *pView=SonViews.GetFirst();pView;pView=SonViews.GetNext())
	{
		if(version==0||
			(doc_type==1&&version>=4010200)||
			(doc_type==2&&version>=1010200)||
			(doc_type==4&&version>=1020200)||
			(doc_type==5&&version>=1020200))
			buffer.WriteInteger(pView->GetViewTypeId());
		pView->ToBuffer(buffer,version,doc_type);
	}
}
void CLDSPartGroup::ToXmlFile(FILE* fp,DWORD schema)
{
	char sText[500]="";
	fprintf(fp,"<组合构件信息 handle=\"0x%x\" FolderName=\"%s\" GroupName=\"%s\">\n",handle,sFolderName,sGroupName);
	fprintf(fp,"<构件组数目 StatMatCoef=\"%d\"/>\n",m_uStatMatCoef);
	fprintf(fp,"<原点坐标 origin=\"(%.3f,%.3f,%.3f)\"/>\n",ucs.origin.x,ucs.origin.y,ucs.origin.z);
	fprintf(fp,"<X轴坐标 axis_x=\"(%.3f,%.3f,%.3f)\"/>\n",ucs.axis_x.x,ucs.axis_x.y,ucs.axis_x.z);
	fprintf(fp,"<Y轴坐标 axis_y=\"(%.3f,%.3f,%.3f)\"/>\n",ucs.axis_y.x,ucs.axis_y.y,ucs.axis_y.z);
	fprintf(fp,"<Z轴坐标 axis_z=\"(%.3f,%.3f,%.3f)\"/>\n",ucs.axis_z.x,ucs.axis_z.y,ucs.axis_z.z);
	if(m_iPartGroupType==GROUP_ENDCONN)
		strcpy(sText,"true");
	else 
		strcpy(sText,"false");
	fprintf(fp,"<标准组焊件 bStdPartGroup=\"%s\"/>\n",sText);
	if(m_bFootPartGroup==1)
		strcpy(sText,"true");
	else
		strcpy(sText,"false");
	fprintf(fp,"<塔脚板组焊件 bFootPartGroup=\"%s\"/>\n",sText);
	fprintf(fp,"<子视图数量 SonViewNum=\"%d\"/>\n",SonViews.GetNodeNum());
	for(CSectionView *pView=SonViews.GetFirst();pView;pView=SonViews.GetNext())
		pView->ToXmlFile(fp,schema);
	fprintf(fp,"</组合构件信息>\n");
}
//doc_tma1_lma2_tsa3_lds4_default0
void CLDSPartGroup::FromBuffer(CBuffer &buffer,long version/*=NULL*/,long doc_type/*=0*/)
{
	if(doc_type==0)
		doc_type=PRODUCT_TYPE;
	buffer.ReadInteger(&handle);
	buffer.ReadString(sFolderName);
	buffer.ReadString(sGroupName);
	buffer.ReadDword(&m_uStatMatCoef);
	buffer.ReadPoint(ucs.origin);
	buffer.ReadPoint(ucs.axis_x);
	buffer.ReadPoint(ucs.axis_y);
	buffer.ReadPoint(ucs.axis_z);
	buffer.ReadInteger(&m_iPartGroupType);	//标准组焊件
	if(  version==0||doc_type==5||			//TDA
		(doc_type==1&&version>=4000025)||	//TMA V4.0.0.25
		(doc_type==2&&version>=1000080)||	//LMA V1.0.0.80
		(doc_type==4&&version>=1000007))	//LDS V1.0.0.7
	{
		buffer.ReadInteger(&m_bFootPartGroup);//塔脚组焊件 wht 10-01-14
		if(m_bFootPartGroup)
			m_iPartGroupType=GROUP_ANGLEFOOT;
	}
	int i,n;
	buffer.ReadInteger(&n);
	for(i=0;i<n;i++)
	{
		int idViewType=CSectionView::CLS_BASIC_VIEW;
		if(version==0||
			(doc_type==1&&version>=4010200)||
			(doc_type==2&&version>=1010200)||
			(doc_type==4&&version>=1020200)||
			(doc_type==5&&version>=1020200))
			buffer.ReadInteger(&idViewType);
		CSectionView *pView=SonViews.Add(0,idViewType);
		pView->FromBuffer(buffer,version,doc_type);
	}
}

//通过旧视图信息生成需要的新视图 主要是在将节点板视图细分为环向封板视图，环向肋板，跨越连板时使用  wht 09-12-12
static CSectionView *AddNewViewByOldView(CLDSPartGroup *pPartGroup,CSectionView *pMainView,CSectionView *pOldView,
										 SECTION_VIEW_TYPE iViewType,int iParamType,int &view_index)
{	
	if(pPartGroup==NULL||pOldView==NULL)
		return NULL;
	//CSectionView *pSectionView=pPartGroup->SonViews.append();
	CSlaveSectionView *pSectionView=(CSlaveSectionView*)pPartGroup->SonViews.Add(0,CSectionView::CLS_SLAVE_VIEW);
	pSectionView->index=view_index++;
	pSectionView->m_iViewType=iViewType;
	pSectionView->m_bLocked=TRUE;	//新添加的端面图必须锁定
	pSectionView->ucs=pOldView->ucs;
	pSectionView->des_cs.SetParamInfo(pOldView->des_cs.GetParamInfo());
	strcpy(pSectionView->sName,pOldView->sName);
	CSectionView::PART_ITEM *pPartItem=NULL;
	pSectionView->SonParts.Empty();
	bool bSetOrg=false;
	for(pPartItem=pOldView->SonParts.GetFirst();pPartItem;pPartItem=pOldView->SonParts.GetNext())
	{
		CSuperSmartPtr<CLDSPart> pTempPart;
		if(TagPart(pPartItem)==NULL||(TagPart(pPartItem)->handle!=pPartItem->hSonPart))
			pTempPart=pPartGroup->BelongModel()->FromPartHandle(pPartItem->hSonPart);
		else
			pTempPart=TagPart(pPartItem);
		if(pTempPart.IsNULL())
			continue;
		CXhChar100 sName;
		if(iViewType==VIEW_CIRPLATE)
		{	//环向板端面图
			if(pTempPart->GetClassTypeId()==CLS_PARAMPLATE)
			{
				int iType=pTempPart.ParamPlatePointer()->m_iParamType;
				if(iType==TYPE_TUBERIBPLATE||iType==TYPE_CIRRIBPLATE||iType==TYPE_CIRCOVERPLATE)
					continue;
			}
			else if(pTempPart->GetClassTypeId()==CLS_PLATE)
			{
				if(pTempPart.PlatePointer()->m_fInnerRadius>0)
					sName.Printf("%s环向板端面视图",(char*)pTempPart->GetPartNo());
			}
			if(!bSetOrg)
			{
				bSetOrg=true;
				CParaCS::PARAMETRIC_INFO param=pSectionView->des_cs.GetParamInfo();
				param.desOrg.datum_pos_style=9;
				param.desOrg.des_para.hPart=pTempPart->handle;
				param.desOrg.datum_pos.Set();
				pSectionView->des_cs.SetParamInfo(param);
				pSectionView->des_cs.UpdateACS(pTempPart->BelongModel());
			}
		}
		else if(iViewType!=VIEW_NODEPLATE)
		{
			if(pTempPart->GetClassTypeId()==CLS_PARAMPLATE)
			{
				if(pTempPart.ParamPlatePointer()->m_iParamType==iParamType)
				{
					if(iParamType==TYPE_TUBERIBPLATE)
						sName.Printf("%s跨越连板视图",(char*)pTempPart->GetPartNo());
					else if(iParamType==TYPE_CIRRIBPLATE)
						sName.Printf("%s环向肋板视图",(char*)pTempPart->GetPartNo());
					else if(iParamType==TYPE_CIRCOVERPLATE)
						sName.Printf("%s环向封板视图",(char*)pTempPart->GetPartNo());
					if(!bSetOrg)
					{
						bSetOrg=true;
						CParaCS::PARAMETRIC_INFO param=pSectionView->des_cs.GetParamInfo();
						param.desOrg.datum_pos_style=9;
						param.desOrg.des_para.hPart=pTempPart->handle;
						param.desOrg.datum_pos.Set();
						pSectionView->des_cs.SetParamInfo(param);
						pSectionView->des_cs.UpdateACS(pTempPart->BelongModel());
					}
				}
				else //不添加其他类型参数化板
					continue;
			}
			else if(pTempPart->GetClassTypeId()==CLS_PLATE)
			{
				if(pTempPart.PlatePointer()->m_fInnerRadius>0)
					continue;
			}
		}
		pSectionView->AddPart(pTempPart->handle,pTempPart);
	}
	//根据宿主视图初始化子视图参数
	pSectionView->InitSlaveSectionView(pMainView,pPartGroup->BelongModel());
	return pSectionView;
}

//添加默认的组焊件附加视图，在添加组焊件附加视图时为每个视图添加默认的标定点，检测线以及角度标注线
void AdjustViewNorm(f3dPoint &axis_z,CLDSPart *pDatumPart)
{
	if(pDatumPart==NULL)
		return;
	f3dPoint verfiy_vec;
	if(pDatumPart->layer(2)=='1'||pDatumPart->layer(2)=='2')
		verfiy_vec.Set(0,1,0);
	else if(pDatumPart->layer(2)=='3'||pDatumPart->layer(2)=='4')
		verfiy_vec.Set(0,-1,0);
	else if(pDatumPart->layer(2)=='Q'||pDatumPart->layer(2)=='q')
		verfiy_vec.Set(0,1,0);
	else if(pDatumPart->layer(2)=='H'||pDatumPart->layer(2)=='h')
		verfiy_vec.Set(0,-1,0);
	else if(pDatumPart->layer(2)=='Z'||pDatumPart->layer(2)=='z')
		verfiy_vec.Set(-1,0,0);
	else if(pDatumPart->layer(2)=='Y'||pDatumPart->layer(2)=='y')
		verfiy_vec.Set(1,0,0);
	else 
		return;
	if(axis_z*verfiy_vec<0)
		axis_z*=-1.0;
}
//1.添加对接相贯钢管视图	移至JointTubePartGroup.cpp
//BOOL CLDSPartGroup::AddJointTubeViews(CLDSLineTube *pRootTube,PARTSET &partset);

//2.四根支管相贯与主管的K节点类组焊件 wht 10-08-13
BOOL CLDSPartGroup::AddKNodeTransectViews(CLDSLineTube *pRootTube,PARTSET &partset)
{
	if(pRootTube==NULL||pRootTube->handle!=handle)
		return FALSE;
	TUBESET branchTubeSet;
	for(CLDSPart *pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
	{
		if(pPart->GetClassTypeId()!=CLS_LINETUBE)
			continue;
		CLDSLineTube *pBranchTube=(CLDSLineTube*)pPart;
		if((pBranchTube->m_tJointStart.type==1&&pBranchTube->m_tJointStart.hLinkObj==pRootTube->handle)
			||(pBranchTube->m_tJointEnd.type==1&&pBranchTube->m_tJointEnd.hLinkObj==pRootTube->handle))
			branchTubeSet.append(pBranchTube);
	}
	if(branchTubeSet.GetNodeNum()>=4)
	{
		//1.主视图
		int view_index=1;
		//CSectionView *pMainView = SonViews.append();
		CSectionView *pMainView = SonViews.Add(0,CSectionView::CLS_BASIC_VIEW);
		pMainView->index=view_index;	//视图索引
		view_index++;
		CParaCS::PARAMETRIC_INFO param = pMainView->des_cs.GetParamInfo();
		//基准点
		param.desOrg.datum_pos_style=1;
		param.desOrg.des_para.RODEND.hRod=pRootTube->handle;
		param.desOrg.des_para.RODEND.bIncOddEffect=TRUE;
		param.desOrg.des_para.RODEND.direction=0;
		//坐标轴
		param.m_eDatumPlane=CParaCS::DP_XY;
		param.desAxisX.norm_style=5;
		param.desAxisX.hVicePart=pRootTube->handle;
		param.desAxisX.direction=0;
		//
		CLDSLineTube *pFirstTube=branchTubeSet.GetFirst();
		param.desAxisY.norm_style=5;
		param.desAxisY.hVicePart=pFirstTube->handle;
		param.desAxisY.direction=0;
		pMainView->des_cs.SetParamInfo(param);
		pMainView->UpdateUCS(m_pModel,this);

		//调整主视图法线方向
		f3dPoint axis_z=pMainView->ucs.axis_z;
		AdjustViewNorm(axis_z,pRootTube);	
		if(axis_z*pMainView->ucs.axis_z<0)
		{
			//pMainView->des_cs.desAxisY.direction=1;
			param.desAxisY.direction=1;
			pMainView->des_cs.SetParamInfo(param);
			pMainView->UpdateUCS(m_pModel,this);
		}

		sprintf(pMainView->sName,"主视图");
		pMainView->m_iViewType=VIEW_MAIN;
		pMainView->AddPart(pRootTube->handle,pRootTube);
		for(pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
			pMainView->AddPart(pPart->handle,pPart);
		//2.简图
		CSectionView *pView=NULL;
		//pView=SonViews.append();
		pView=SonViews.Add(0,CSectionView::CLS_BASIC_VIEW);
		pView->index=view_index;
		view_index++;
		pView->des_cs=pMainView->des_cs;
		pView->ucs=pMainView->ucs;
		sprintf(pView->sName,"正面简图");
		pView->m_iViewType=VIEW_KNODESKETCH;
		pView->AddPart(pRootTube->handle,pRootTube);
		for(pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
		{
			if(pPart->GetClassTypeId()!=CLS_PARAMPLATE)
				continue;
			CLDSParamPlate *pParamPlate=(CLDSParamPlate*)pPart;
			if(!pParamPlate->IsFL())
				continue;
			//if(fabs(pParamPlate->ucs.axis_z*pView->ucs.axis_z)>EPS2)
			//	continue;
			pView->AddPart(pParamPlate->handle,pParamPlate);
		}
		//3.侧面视图
		//pView=SonViews.append();
		pView=SonViews.Add(0,CSectionView::CLS_BASIC_VIEW);
		pView->index=view_index;
		view_index++;
		param = pView->des_cs.GetParamInfo();
		param.desOrg=pMainView->des_cs.GetParamInfo().desOrg;
		param.m_eDatumPlane=CParaCS::DP_XZ;
		param.desAxisX=pMainView->des_cs.GetParamInfo().desAxisX;
		param.desAxisZ=pMainView->des_cs.GetParamInfo().desAxisY;
		pView->des_cs.SetParamInfo(param);
		//TODO:是不是有问题,替换成上一行代码 wjh 2012.11.20
		//pMainView->UpdateUCS(m_pModel,this);

		sprintf(pView->sName,"侧面视图");
		pView->m_iViewType=VIEW_FRONT;
		pView->AddPart(pRootTube->handle,pRootTube);
		for(pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
		{
			if(pPart->handle==pRootTube->handle)
				continue;
			CLDSLineTube *pTempTube=NULL;
			for(pTempTube=branchTubeSet.GetFirst();pTempTube;pTempTube=branchTubeSet.GetNext())
			{
				if(pTempTube->handle==pPart->handle)
					break;
			}
			if(pTempTube)
				continue;
			if(pPart->GetClassTypeId()==CLS_PARAMPLATE)
			{
				CLDSParamPlate *pParamPlate=(CLDSParamPlate*)pPart;
				if(pParamPlate->IsFL()
					&&pParamPlate->m_hPartWeldParent!=pRootTube->handle)
					continue;
			}
			if(pPart->GetClassTypeId()==CLS_PLATE)
			{	
				if(fabs(pPart->ucs.axis_z*pView->ucs.axis_z)>EPS_COS2)
					pView->AddPart(pPart->handle,pPart);
			}
			else 
				pView->AddPart(pPart->handle,pPart);
		}
		//4.端面视图
		//pView=SonViews.append();
		pView=SonViews.Add(0,CSectionView::CLS_BASIC_VIEW);
		pView->index=view_index;
		view_index++;
		param = pView->des_cs.GetParamInfo();
		param.desOrg=pMainView->des_cs.GetParamInfo().desOrg;
		param.m_eDatumPlane=CParaCS::DP_ZX;
		param.desAxisZ=pMainView->des_cs.GetParamInfo().desAxisX;
		param.desAxisX=pMainView->des_cs.GetParamInfo().desAxisY;
		pView->des_cs.SetParamInfo(param);
		pView->UpdateUCS(m_pModel,this);
		
		sprintf(pView->sName,"端面视图");
		pView->m_iViewType=VIEW_NODEPLATE;
		pView->AddPart(pRootTube->handle,pRootTube);
		for(pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
		{
			if(pPart->GetClassTypeId()==CLS_PARAMPLATE)
			{
				CLDSParamPlate *pParamPlate=(CLDSParamPlate*)pPart;
				if(pParamPlate->IsFL()||pParamPlate->m_iParamType==TYPE_ELBOWPLATE)
					continue;
			}
			CLDSLineTube *pTempTube=NULL;
			for(pTempTube=branchTubeSet.GetFirst();pTempTube;pTempTube=branchTubeSet.GetNext())
			{
				if(pTempTube->handle==pPart->handle)
					break;
			}
			if(pTempTube)
				continue;
			pView->AddPart(pPart->handle);
		}
		return TRUE;
	}
	return FALSE;
}
//3.添加基准构件为杆件的组焊件视图
struct PARTGROUP_WORKPLANE_STRU{
	char sName[51];
	CLDSPart *pDatumPart;
	f3dPoint workPlaneNorm,workPlaneOrg;
	CParaCS::PARAMETRIC_INFO csParaInfo;
	int nRayTubeNum,nPartNum;	//工作面优先级的判断依据
	CDrawingAssistant assistant;
	PARTGROUP_WORKPLANE_STRU(){
		memset(sName,0,51);
		nRayTubeNum=nPartNum=0;
		csParaInfo.m_cDefStyle=CParaCS::CS_PARAM;
		csParaInfo.m_eDatumPlane=CParaCS::DP_XY;
	}
	f3dPoint GetYAxisVec()
	{
		CParaCS des_cs;
		des_cs.SetParamInfo(csParaInfo);
		des_cs.SetModifiedState();
		CLDSPart* pPart=pDatumPart->BelongModel()->FromPartHandle(csParaInfo.desAxisZ.hVicePart);
		//TODO: 需要进一步优化　wjh-2014.8.14
		if(!pDatumPart->IsPlate())
			return des_cs.GetACS().axis_y;
		else
		{
			CLDSGeneralPlate* pPlate=(CLDSGeneralPlate*)pDatumPart;
			GEPOINT pick_y=pPlate->vertex_list.GetFirst()->vertex;
			coord_trans(pick_y,pPlate->ucs,TRUE);
			GEPOINT justify_vec=pick_y-des_cs.GetACS().origin;
			if(justify_vec*des_cs.GetACS().axis_y<0)
				return -des_cs.GetACS().axis_y;
			else
				return des_cs.GetACS().axis_y;
		}
	}
};
//校正钢板工作平面(绘图)法线的正向，以使钢板尽量接尽其自然视角 wjh-2013.12.07
GEPOINT AdjustPlateWorkPlaneNorm(double* axis_z,char cPosLayer)
{
	GEPOINT work_norm(axis_z);
	if(toupper(cPosLayer)=='Q'&&fabs(work_norm.y)>0.707&&work_norm.y<0)	//前视图钢板，法线应尽量显示为Y轴正向
		work_norm *=-1.0;
	else if(toupper(cPosLayer)=='H'&&fabs(work_norm.y)>0.707&&work_norm.y>0)	//前视图钢板，法线应尽量显示为Y轴正向
		work_norm *=-1.0;
	else if(toupper(cPosLayer)=='Z'&&fabs(work_norm.x)>0.707&&work_norm.x>0)	//前视图钢板，法线应尽量显示为Y轴正向
		work_norm *=-1.0;
	else if(toupper(cPosLayer)=='Y'&&fabs(work_norm.x)>0.707&&work_norm.x<0)	//前视图钢板，法线应尽量显示为Y轴正向
		work_norm *=-1.0;
	return work_norm;
}


//<DEVELOP_PROCESS_MARK nameId="CLDSPartGroup::ExtractSectionSegs">
//3.1 初始化组焊件工作面
//3.2 添加工作面对应的视图
//3.3 基准构件为钢管时需要添加钢管端面视图
//3.3.1 无主视图(如钢管两端均为法兰且钢管上无连接板的情况)时添加主视图
//3.3.2 添加钢管中间节点对应的端面视图
typedef struct tagSECTION_PART{
	CLDSPart *pPart;
	f3dLine prjLine;
	tagSECTION_PART(){pPart=NULL;}
}SECTION_PART;
typedef struct tagSECTION_SEG{
	const static int SECTION_SPACE_THRESHOLD	= 500;	//节点区间间距阈值
	//
	const static int SECTION_TYPE_NODEPLATE		= 0x0;	//0x00.节点板视图 
	const static int SECTION_TYPE_TUBERIBPLATE	= 0x01;	//0x01.跨越连板视图 
	const static int SECTION_TYPE_CIRCOVERPLATE	= 0x02;	//0x02.环向封板视图 
	const static int SECTION_TYPE_CIRRIBPLATE	= 0x04;	//0x04.环向肋板视图 
	const static int SECTION_TYPE_CIRPLATE		= 0x08;	//0x08.环向板端面视图
	//
	BYTE m_cSectionType;	
	SECTION_PART *m_pStartPart;
	SECTION_PART *m_pEndPart;
	SECTION_PART *m_pDatumPart;
	ATOM_LIST<SECTION_PART> sectionPartList;
	//
	tagSECTION_SEG()
	{
		m_cSectionType=0;
		m_pStartPart=m_pEndPart=m_pDatumPart=NULL;
	}
	f3dPoint GetSectionDatumPos()
	{
		return f3dPoint();
	}
	BOOL IsIncludeSectionPart(SECTION_PART *pPart)
	{	
		if(m_pStartPart==NULL||m_pEndPart==NULL)
			return TRUE;
		SECTION_PART *pEndPart=m_pEndPart,*pCurPart=pPart;
		if(pPart->prjLine.startPt.z<m_pEndPart->prjLine.startPt.z)
		{
			pEndPart=pPart;
			pCurPart=m_pEndPart;
		}
		//1.两线段重叠
		if(pCurPart->prjLine.startPt.z<=pEndPart->prjLine.endPt.z)	
			return TRUE;
		//2.与终端构件间距大于节点区间间距阈值
		else if(pCurPart->prjLine.startPt.z>pEndPart->prjLine.endPt.z+SECTION_SPACE_THRESHOLD)
			return FALSE;
		//3.与终端构件间距小于等于节点区间间距阈值
		else 
			return TRUE;
	}
}SECTION_SEG;
//提取SectionSegs
static void ExtractSectionSegs(CLDSLineTube *pLineTube,PARTSET &partset,ATOM_LIST<SECTION_SEG> &sectionSegList)
{	//1.遍历partset将钢板和指定类型的参数化板向基准钢板投影，计算构件对应的投影线段(保证投影线段有序)
	ATOM_LIST<SECTION_PART> sectionPartList;
	//统计汇总partset中所有钢管关联的法兰插板以及附属件
	CHashTable<long> hashPartHandleByHandle;
	hashPartHandleByHandle.CreateHashTable(partset.GetNodeNum());
	CLDSPart *pPart=NULL;
	for(pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
	{
		if(!pPart->IsTube())
			continue;
		CLDSLineTube *pTempTube=(CLDSLineTube*)pPart;
		for(int i=0;i<2;i++)
		{
			long hEndLj=pTempTube->m_tJointStart.hLinkObj;
			if(i==1)
				hEndLj=pTempTube->m_tJointEnd.hLinkObj;
			CLDSParamPlate *pEndLjPlate=(CLDSParamPlate*)pLineTube->BelongModel()->FromPartHandle(hEndLj,CLS_PARAMPLATE);
			if(pEndLjPlate)
			{
				if(!hashPartHandleByHandle.ContainsKey(pEndLjPlate->handle))
					hashPartHandleByHandle.SetValueAt(pEndLjPlate->handle,pEndLjPlate->handle);
				for(ATTACHPART_ITEM *pItem=pEndLjPlate->GetFirstAttachPart();pItem;pItem=pEndLjPlate->GetNextAttachPart())
				{
					if(!hashPartHandleByHandle.ContainsKey(pItem->h))
						hashPartHandleByHandle.SetValueAt(pItem->h,pItem->h);
				}
			}
		}
	}
	for(pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
	{
		ATOM_LIST<PROFILE_VERTEX> *pVertexList=NULL;
		if(pPart->GetClassTypeId()==CLS_PLATE)
		{
			CLDSPlate *pPlate=(CLDSPlate*)pPart;
			pVertexList=&pPlate->vertex_list;
		}
		else if(pPart->GetClassTypeId()==CLS_PARAMPLATE)
		{
			CLDSParamPlate *pParamPlate=(CLDSParamPlate*)pPart;
			//仅生成以下三种参数化板对应的端面图 wht 12-09-06
			if(pParamPlate->m_iParamType!=TYPE_CIRCOVERPLATE&&
				pParamPlate->m_iParamType!=TYPE_CIRRIBPLATE&&
				pParamPlate->m_iParamType!=TYPE_TUBERIBPLATE)
				continue;
			//法兰，插板附加板不在此处添加端面视图
			if(pParamPlate&&hashPartHandleByHandle.ContainsKey(pParamPlate->handle))
				continue;
			if(pParamPlate->vertex_list.GetNodeNum()<=3)
				pParamPlate->DesignPlate(false);
			pVertexList=&pParamPlate->vertex_list;
		}
		if(pVertexList==NULL)
			continue;
		SECTION_PART sectionPart;
		f3dLine datum_line(pLineTube->Start(),pLineTube->End());
		for(PROFILE_VERTEX *pVertex=pVertexList->GetFirst();pVertex;pVertex=pVertexList->GetNext())
		{
			f3dPoint vertex=pVertex->vertex,prjPt;
			coord_trans(vertex,pPart->ucs,TRUE);
			SnapPerp(&prjPt,datum_line,vertex);
			coord_trans(prjPt,pLineTube->ucs,FALSE);
			if(sectionPart.pPart==NULL)
			{
				sectionPart.prjLine.startPt=sectionPart.prjLine.endPt=prjPt;
				sectionPart.pPart=pPart;
			}
			else if(prjPt.z<sectionPart.prjLine.startPt.z)
				sectionPart.prjLine.startPt=prjPt;
			else if(prjPt.z>sectionPart.prjLine.endPt.z)
				sectionPart.prjLine.endPt=prjPt;
		}
		SECTION_PART *pSectionPart=NULL;
		for(pSectionPart=sectionPartList.GetFirst();pSectionPart;pSectionPart=sectionPartList.GetNext())
		{
			if(pSectionPart->prjLine.startPt.z>sectionPart.prjLine.startPt.z)
			{
				sectionPartList.insert(sectionPart);
				break;
			}
		}
		if(pSectionPart==NULL)
			sectionPartList.append(sectionPart);
	}
	//2.根据指定的阈值将SectionParts划分到不同区间段
	sectionSegList.Empty();
	for(SECTION_PART *pTempSectionPart=sectionPartList.GetFirst();pTempSectionPart;pTempSectionPart=sectionPartList.GetNext())
	{
		SECTION_SEG *pSectionSeg=sectionSegList.GetTail();
		if(pSectionSeg==NULL||!pSectionSeg->IsIncludeSectionPart(pTempSectionPart))
		{
			pSectionSeg=sectionSegList.append();
			pSectionSeg->m_cSectionType=SECTION_SEG::SECTION_TYPE_NODEPLATE;
			SECTION_PART *pNewSectionPart=pSectionSeg->sectionPartList.append(*pTempSectionPart);
			pSectionSeg->m_pStartPart=pSectionSeg->m_pEndPart=pNewSectionPart;
		}
		else 
		{
			SECTION_PART *pNewSectionPart=pSectionSeg->sectionPartList.append(*pTempSectionPart);
			pSectionSeg->m_pEndPart=pNewSectionPart;
		}
		
		if(pTempSectionPart->pPart&&pTempSectionPart->pPart->IsPlate())
		{
			if(pTempSectionPart->pPart->GetClassTypeId()==CLS_PLATE&&((CLDSPlate*)pTempSectionPart->pPart)->m_fInnerRadius>0)
				pSectionSeg->m_cSectionType|=SECTION_SEG::SECTION_TYPE_CIRPLATE;
			else if(pTempSectionPart->pPart->GetClassTypeId()==CLS_PARAMPLATE)
			{
				CLDSParamPlate *pParamPlate=(CLDSParamPlate*)pTempSectionPart->pPart;
				if(pParamPlate->m_iParamType==TYPE_CIRCOVERPLATE)
					pSectionSeg->m_cSectionType|=SECTION_SEG::SECTION_TYPE_CIRCOVERPLATE;
				else if(pParamPlate->m_iParamType==TYPE_CIRRIBPLATE)
					pSectionSeg->m_cSectionType|=SECTION_SEG::SECTION_TYPE_CIRRIBPLATE;
				else if(pParamPlate->m_iParamType==TYPE_TUBERIBPLATE)
					pSectionSeg->m_cSectionType|=SECTION_SEG::SECTION_TYPE_TUBERIBPLATE;
			}
		}
	}
}
//</DEVELOP_PROCESS_MARK>

//<DEVELOP_PROCESS_MARK nameId="CLDSPartGroup::AddLineTubeMiddleNodeEndView">
//基准构件为钢管，为每个节点添加端面视图 保证端面图与主视图匹配
//TODO: 基准杆件上剖切面节点不能直接根据GetBaseNode获取(尤其是钢管夹板时不对)，应考虑：
//将沿向钢板向基准杆件上投影，投影线重叠或距离在一定范围内时视同一个节点 wjh-2013.12.08
BOOL CLDSPartGroup::AddLineTubeMiddleNodeEndView(CLDSLineTube *pLineTube,CSectionView *pMainView,PARTSET &partset,int &view_index)
{
	ATOM_LIST<SECTION_SEG> sectionSegList;
	//1.提取区间段
	ExtractSectionSegs(pLineTube,partset,sectionSegList);
	if(sectionSegList.GetNodeNum()<=0)
		return FALSE;
	//2.为每个区间段生成一组视图
	for(SECTION_SEG *pSectionSeg=sectionSegList.GetFirst();pSectionSeg;pSectionSeg=sectionSegList.GetNext())
	{
		CSectionView sectionView;
		sectionView.m_bLocked=TRUE;
		//设置视图坐标系参数
		CParaCS::PARAMETRIC_INFO param=sectionView.des_cs.GetParamInfo();
		//基准点
		param.desOrg.datum_pos_style=1;
		param.desOrg.des_para.RODEND.hRod=pLineTube->handle;
		param.desOrg.des_para.RODEND.bIncOddEffect=TRUE;
		param.desOrg.des_para.RODEND.direction=0;
		//坐标轴
		param.m_eDatumPlane=CParaCS::DP_ZX;
		param.desAxisZ.norm_style=5;
		param.desAxisZ.hVicePart=pLineTube->handle;
		param.desAxisZ.direction=1;

		if(pMainView&&pMainView->des_cs.IsDesAxisZ())
			param.desAxisX=pMainView->des_cs.GetParamInfo().desAxisZ;
		else
		{
			param.desAxisX.norm_style=4;
			param.desAxisX.hVicePart=pLineTube->handle;
			param.desAxisX.nearVector.Set(1,0,0);
		}
		sectionView.des_cs.SetParamInfo(param);
		sectionView.UpdateUCS(m_pModel,this);
		//填充视图构件集合
		sectionView.AddPart(pLineTube->handle,pLineTube);
		for(SECTION_PART *pSectionPart=pSectionSeg->sectionPartList.GetFirst();pSectionPart;pSectionPart=pSectionSeg->sectionPartList.GetNext())
		{
			CXhChar100 sName;
			CLDSPart *pPart=NULL;
			if(pSectionPart->pPart!=NULL)
				pPart=pSectionPart->pPart;
			if(pPart&&pPart->GetClassTypeId()==CLS_PLATE)
				sName.Printf("%s节点板端面图",(char*)pPart->GetPartNo());
			else if(pPart&&sName.Length()<=0)
				sName.Printf("%s构件端面图",(char*)pPart->GetPartNo());
			else if(sName.Length()<=0)
				sName.Printf("端面图");
			strcpy(sectionView.sName,sName);
			sectionView.AddPart(pPart->handle,pPart);
		}
		if(pSectionSeg->m_cSectionType==SECTION_SEG::SECTION_TYPE_NODEPLATE)
			AddNewViewByOldView(this,pMainView,&sectionView,VIEW_NODEPLATE,0,view_index);
		else 
		{
			if(pSectionSeg->m_cSectionType&SECTION_SEG::SECTION_TYPE_TUBERIBPLATE)	//添加跨越连板视图
				AddNewViewByOldView(this,pMainView,&sectionView,VIEW_TUBERIBPLATE,TYPE_TUBERIBPLATE,view_index);
			if(pSectionSeg->m_cSectionType&SECTION_SEG::SECTION_TYPE_CIRCOVERPLATE)	//添加环向封板视图
				AddNewViewByOldView(this,pMainView,&sectionView,VIEW_CIRCOVERPLATE,TYPE_CIRCOVERPLATE,view_index);
			if(pSectionSeg->m_cSectionType&SECTION_SEG::SECTION_TYPE_CIRRIBPLATE)	//添加环向肋板视图
				AddNewViewByOldView(this,pMainView,&sectionView,VIEW_CIRRIBPLATE,TYPE_CIRRIBPLATE,view_index);
			if(pSectionSeg->m_cSectionType&SECTION_SEG::SECTION_TYPE_CIRPLATE)		//添加环向板端面图
				AddNewViewByOldView(this,pMainView,&sectionView,VIEW_CIRPLATE,0,view_index);
		}
	}
	return TRUE;
}
//</DEVELOP_PROCESS_MARK>

//<DEVELOP_PROCESS_MARK nameId="CLDSPartGroup::AddLineTubeEndLjView">
//3.3.3 添加钢管端板视图(包括平面切割、法兰、插板、塔脚板)
BOOL CLDSPartGroup::AddLineTubeEndLjView(CLDSLineTube *pLineTube,CSectionView *pMainView,PARTSET &partset,int iStartView,int &view_index)
{
	int i=0;
	f3dPoint tube_vec=pLineTube->End()-pLineTube->Start();
	normalize(tube_vec);
	//1 为平面切割的主材钢管添加切割投影面视图
	f3dPoint cut_norm;
	for(i=0;i<2;i++)
	{
		TUBEJOINT *pTubeJoint=NULL;
		if(i==0)
			pTubeJoint=&pLineTube->m_tJointStart;
		else 
			pTubeJoint=&pLineTube->m_tJointEnd;
		if(pTubeJoint->cutPlaneNorm.IsZero()||fabs(pTubeJoint->cutPlaneNorm*tube_vec)>EPS_COS)
			continue;	//切割面法线方向为0或与钢管延伸方向平行
		if(i==1&&fabs(pTubeJoint->cutPlaneNorm*cut_norm)>EPS_COS)
			continue;	//避免始终端切割面法线相同同时重复添加视图的情况
		cut_norm=pTubeJoint->cutPlaneNorm;

		//CSectionView *pSectionView = SonViews.append();
		CSlaveSectionView *pSectionView = (CSlaveSectionView*)SonViews.Add(0,CSectionView::CLS_SLAVE_VIEW);
		pSectionView->index=view_index;	//视图索引
		view_index++;
		pSectionView->m_iViewType=VIEW_FRONT;
		//
		CParaCS::PARAMETRIC_INFO param = pSectionView->des_cs.GetParamInfo();
		//基准点
		param.desOrg.datum_pos_style=1;
		param.desOrg.des_para.RODEND.hRod=pLineTube->handle;
		param.desOrg.des_para.RODEND.bIncOddEffect=TRUE;
		param.desOrg.des_para.RODEND.direction=0;
		//坐标轴
		param.m_eDatumPlane=CParaCS::DP_XY;
		param.desAxisX.norm_style=5;	//基准杆件上的特征方向
		param.desAxisX.hVicePart=pLineTube->handle;
		param.desAxisX.direction=0;

		param.desAxisY.norm_style=5;
		param.desAxisY.hVicePart=pLineTube->handle;
		if(i==0)
			param.desAxisY.direction=4;
		else
			param.desAxisY.direction=5;
		pSectionView->des_cs.SetParamInfo(param);
		pSectionView->UpdateUCS(m_pModel,this);
		//
		if(i==0)
			strcpy(pSectionView->sName,"始端切割面投影视图");	//"始端对角面视图");
		else
			strcpy(pSectionView->sName,"终端切割面投影视图");	//"终端对角面视图");
		pSectionView->AddPart(pLineTube->handle,pLineTube);
		for(CLDSPart *pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
			pSectionView->AddPart(pPart->handle,pPart);
		//
		pSectionView->InitSlaveSectionView(pMainView,BelongModel());
	}
	//2 添加钢管端头视图  法兰视图，插板视图
	char sPartNo[50]="";
	for(i=0;i<2;i++)
	{
		CLDSParamPlate *pEndLj=NULL;
		if(i==0&&pLineTube->m_tJointStart.hLinkObj>0x20)
			pEndLj=(CLDSParamPlate*)BelongModel()->FromPartHandle(pLineTube->m_tJointStart.hLinkObj,CLS_PARAMPLATE);
		else if(i==1&&pLineTube->m_tJointEnd.hLinkObj>0x20)
			pEndLj=(CLDSParamPlate*)BelongModel()->FromPartHandle(pLineTube->m_tJointEnd.hLinkObj,CLS_PARAMPLATE);
		if(pEndLj==NULL)
			continue;
		if(i==1&&pEndLj->IsInsertPlate()&&strlen(sPartNo)>0&&strcmp(sPartNo,pEndLj->GetPartNo())==0)
			continue;	//始终端插板编号相同
		if(!pEndLj->IsFL()&&!pEndLj->IsInsertPlate())
			continue;	//只针对法兰及插板生成钢管端头视图 wht 12-09-06
		CSlaveSectionView *pSectionView = (CSlaveSectionView*)SonViews.Add(0,CSectionView::CLS_SLAVE_VIEW);
		//CSectionView *pSectionView = SonViews.append();
		pSectionView->m_bLocked=TRUE;
		if(i==0&&iStartView>0)
			pSectionView->index=iStartView;
		else
		{
			pSectionView->index=view_index;
			view_index++;
		}
		pSectionView->AddPart(pLineTube->handle,pLineTube);
		pSectionView->AddPart(pEndLj->handle,pEndLj);
		if(pEndLj->m_iParamType==TYPE_XEND)
		{	//将十字插板附加构件添加到十字插板端面图中 wht 10-06-29
			ATTACHPART_ITEM *pItem=NULL;
			for(pItem=pEndLj->GetFirstAttachPart();pItem;pItem=pEndLj->GetNextAttachPart())
			{
				CLDSPlate *pAttachPlate=(CLDSPlate*)m_pModel->FromPartHandle(pItem->h,CLS_PLATE);
				if(pAttachPlate==NULL)
					continue;
				if(pAttachPlate->m_hPartWeldParent!=pEndLj->handle)
					continue;
				//仅添加焊接父构件为十字插板基板的附加板 wht 10-08-06
				pSectionView->AddPart(pItem->h);
			}
		}
		CParaCS::PARAMETRIC_INFO param=pSectionView->des_cs.GetParamInfo();
		//基准点
		param.desOrg.datum_pos_style=9;
		param.desOrg.des_para.hPart=pEndLj->handle;

		param.m_eDatumPlane=CParaCS::DP_ZX;
		//X轴 调整端面图坐标系与主正视图保持一致
		if(pMainView&&pMainView->des_cs.IsDesAxisZ())
			param.desAxisX=pMainView->des_cs.GetParamInfo().desAxisZ;
		else
		{
			param.desAxisX.norm_style=4;
			param.desAxisX.hVicePart=pLineTube->handle;
			param.desAxisX.nearVector.Set(1,0,0);
		}
		if(pEndLj->IsFL())
		{
			//Z轴
			param.desAxisZ.norm_style=3;
			param.desAxisZ.hVicePart=pEndLj->handle;
			param.desAxisZ.direction=0;
			//调整视图坐标系方向为杆件指向法兰的负方向
			if(pEndLj->m_iParamType==TYPE_FL)
				param.desAxisZ.direction=1;
			if(i==0)
				strcpy(pSectionView->sName,"始端法兰视图");
			else 
				strcpy(pSectionView->sName,"终端法兰视图");
			pSectionView->m_iViewType=VIEW_FL;
			//将法兰上的肘板添加到法兰视图中
			if(pEndLj->m_iParamType==TYPE_FL)
			{
				ATTACHPART_ITEM *pAttachItem=NULL;
				for(pAttachItem=pEndLj->GetFirstAttachPart();pAttachItem;pAttachItem=pEndLj->GetNextAttachPart())
					pSectionView->AddPart(pAttachItem->h);
				for(CLDSPart* pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
				{	//添加有焊接关系，但不是附加肘板的普通钢板
					if(!pPart->IsPlate())
						continue;
					if(pEndLj->GetAttachPartList()->GetValue(pPart->handle)!=NULL)
						continue;
					CLDSGeneralPlate* pPlate=(CLDSGeneralPlate*)pPart;
					for(PROFILE_VERTEX* pVertex=pPlate->vertex_list.GetFirst();pVertex;pVertex=pPlate->vertex_list.GetNext())
					{
						if(pVertex->m_bWeldEdge&&pVertex->weldline.hWeldMontherPart==pEndLj->handle)
						{
							pAttachItem=pEndLj->AttachPart.Add(pPlate->handle);
							pAttachItem->idClsType=pPlate->GetClassTypeId();
							strncpy(pAttachItem->sPartNo,pPlate->GetPartNo(),16);
							pSectionView->AddPart(pPlate->handle);
							break;
						}
					}
				}

			}
		}
		else if(pEndLj->m_iParamType==TYPE_ROLLEND||pEndLj->m_iParamType==TYPE_UEND||pEndLj->m_iParamType==TYPE_XEND)
		{	//Z轴
			param.desAxisZ.norm_style=4;
			param.desAxisZ.hVicePart=pEndLj->handle;
			param.desAxisZ.nearVector.Set(1,0,0);
			if(i==0)	//始端
				strcpy(sPartNo,pEndLj->GetPartNo());
			sprintf(pSectionView->sName,"%s插板视图",(char*)pEndLj->GetPartNo());
			pSectionView->m_iViewType=VIEW_INSERTPLATE;
		}
		pSectionView->des_cs.SetParamInfo(param);
		pSectionView->UpdateUCS(m_pModel,this);
		pSectionView->InitSlaveSectionView(pMainView,BelongModel());
	}
	//3. 添加(始)终端法兰视图(塔脚板) wht 12-09-06
	for(int i=0;i<2;i++)
	{
		f3dPoint datum_axis_z=tube_vec;
		CLDSNode *pDatumNode=NULL;
		TUBEJOINT *pTubeJoint=NULL;
		if(i==0)
		{
			pTubeJoint=&pLineTube->m_tJointStart;
			pDatumNode=pLineTube->pStart;
		}
		else 
		{
			pTubeJoint=&pLineTube->m_tJointEnd;
			pDatumNode=pLineTube->pEnd;
			datum_axis_z*=-1.0;
		}
		if(pTubeJoint==NULL||pTubeJoint->cutPlaneNorm.IsZero()||pDatumNode==NULL)
			continue;
		CLDSPart *pDatumPlate=NULL;
		for(CLDSPart *pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
		{
			if(!pPart->IsPlate()||fabs(pPart->ucs.axis_z*pTubeJoint->cutPlaneNorm)<EPS_COS2)
				continue;
			if(pPart->GetClassTypeId()==CLS_PLATE)
			{
				CLDSPlate *pPlate=(CLDSPlate*)pPart;
				if(pPlate->m_fInnerRadius<0)
					continue;
				CLDSNode *pBaseNode=pPlate->GetBaseNode();
				if(pBaseNode==pDatumNode)
				{
					pDatumPlate=pPart;
					break;
				}
			}
			else if(pPart->GetClassTypeId()==CLS_PARAMPLATE)
			{
				CLDSParamPlate *pParamPlate=(CLDSParamPlate*)pPart;
				double B=0;
				if(pParamPlate->m_iParamType!=TYPE_CIRRIBPLATE||
					!pParamPlate->GetDesignItemValue('B',&B,NULL)||fabs(B-360)>EPS_COS)	//B:β,环向扇形角(外形参数)
					continue;
				CLDSNode *pBaseNode=pParamPlate->GetBaseNode();
				if(pBaseNode==pDatumNode)
				{
					pDatumPlate=pPart;
					break;
				}
			}
		}
		if(pDatumPlate)
		{	
			//CSectionView *pSectionView = SonViews.append();
			CSlaveSectionView *pSectionView = (CSlaveSectionView*)SonViews.Add(0,CSectionView::CLS_SLAVE_VIEW);
			pSectionView->index=view_index;	//视图索引
			view_index++;
			pSectionView->m_iViewType=VIEW_FL;
			//
			CParaCS::PARAMETRIC_INFO param=pSectionView->des_cs.GetParamInfo();
			//基准点
			param.desOrg.datum_pos_style=1;
			param.desOrg.des_para.RODEND.hRod=pLineTube->handle;
			param.desOrg.des_para.RODEND.bIncOddEffect=TRUE;
			param.desOrg.des_para.RODEND.direction=i;
			//坐标轴
			param.m_eDatumPlane=CParaCS::DP_ZX;
			param.desAxisZ.norm_style=3;
			param.desAxisZ.hVicePart=pDatumPlate->handle;
			if(datum_axis_z*pPart->ucs.axis_z<0)
				param.desAxisZ.direction=1;
			else 
				param.desAxisZ.direction=0;

			param.desAxisX.norm_style=4;
			param.desAxisX.hVicePart=pDatumPlate->handle;
			param.desAxisX.nearVector.Set(1,0,0);
			pSectionView->des_cs.SetParamInfo(param);
			pSectionView->UpdateUCS(m_pModel,this);
			//
			if(i==0)
				strcpy(pSectionView->sName,"始端底脚法兰视图");
			else
				strcpy(pSectionView->sName,"终端底脚法兰视图");
			pSectionView->AddPart(pDatumPlate->handle,pDatumPlate);
			pSectionView->AddPart(pLineTube->handle,pLineTube);
			for(CLDSPart *pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
			{
				if(!pPart->IsPlate()||pDatumPlate->handle==pPart->handle)
					continue;
				if(pPart->GetClassTypeId()==CLS_PLATE)
				{
					CLDSPlate *pPlate=(CLDSPlate*)pPart;
					CLDSNode *pBaseNode=pPlate->GetBaseNode();
					if(pBaseNode!=pDatumNode)
						continue;
				}
				else if(pPart->GetClassTypeId()==CLS_PARAMPLATE)
				{
					CLDSParamPlate *pParamPlate=(CLDSParamPlate*)pPart;
					if(pParamPlate->m_iParamType!=TYPE_RIBPLATE&&pParamPlate->m_iParamType!=TYPE_ELBOWPLATE)
						continue;
					CLDSNode *pBaseNode=pParamPlate->GetBaseNode();
					if(pBaseNode!=pDatumNode)
						continue;
				}
				pSectionView->AddPart(pPart->handle,pPart);
			}
			//
			pSectionView->InitSlaveSectionView(pMainView,BelongModel());
		}
	}
	return TRUE;
}
//</DEVELOP_PROCESS_MARK>

//<DEVELOP_PROCESS_MARK nameId="CLDSPartGroup::AddFootNailView">
//3.3.4 为组焊件中脚钉底座添加端面图
BOOL CLDSPartGroup::AddFootNailView(CLDSLineTube *pLineTube,CSectionView *pMainView,PARTSET &partset,int &view_index)
{
	CHashTable<CSectionView*> hashViewByWeldParentHandle;
	hashViewByWeldParentHandle.CreateHashTable(partset.GetNodeNum());
	for(CLDSPart *pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
	{
		CLDSBolt *pBolt=NULL;	//脚钉底座上的脚钉,某些情况会存在不带脚钉的脚钉底座
		CLDSLineSlot *pLineSlot=NULL;
		CLDSLineAngle *pLineAngle=NULL;
		if(pPart->GetClassTypeId()==CLS_LINESLOT)
		{	//存在脚钉底座
			pLineSlot=(CLDSLineSlot*)pPart;
			pLineSlot->BuildUCS();
			if(pLineSlot->GetLsCount()!=1)
				continue;	
			pBolt=pLineSlot->GetFirstLsRef()->GetLsPtr();
			if(pBolt==NULL)
				continue;
			if(!pBolt->IsFootNail())
				continue;	//非脚钉底座
		}
		else if(pPart->GetClassTypeId()==CLS_LINEANGLE)
		{	//存在角钢脚钉
			pLineAngle=(CLDSLineAngle*)pPart;
			if(pLineAngle==NULL)
				continue;
			pLineAngle->getUCS(pLineAngle->ucs);
			if(!pLineAngle->m_bFootNail)
				continue;	//非角钢脚钉
		}
		if(pLineSlot==NULL&&pLineAngle==NULL)
			continue;
		//此处以脚钉底座/角钢角钢的焊接父构件为关键字
		CSectionView *pView=NULL;
		if(hashViewByWeldParentHandle.GetValueAt(pPart->m_hPartWeldParent,pView))
		{
			if(pView==NULL)
				continue;
			BOOL bIgnoreSlot=FALSE;	//不重复添加与视图中脚钉角度相同的脚钉
			BOOL bIgnoreAngle=FALSE;//不重复添加与视图中脚钉角度相同的脚钉
			CSectionView::PART_ITEM *pPartItem = NULL;
			for(pPartItem=pView->SonParts.GetFirst();pPartItem;pPartItem=pView->SonParts.GetNext())
			{
				if(TagPart(pPartItem)==NULL)
					continue;
				double cosa=0;
				if(pLineSlot)
				{
					cosa=pLineSlot->ucs.axis_y*TagPart(pPartItem)->ucs.axis_y;
					if(cosa>EPS_COS)
					{
						bIgnoreSlot=TRUE;
						break;
					}
				}
				else if(pLineAngle)
				{
					cosa=pLineAngle->ucs.axis_z*TagPart(pPartItem)->ucs.axis_z;
					if(cosa>EPS_COS)
					{
						bIgnoreAngle=TRUE;
						break;
					}
				}

			}
			if((pLineSlot&&bIgnoreSlot)||(pLineAngle&&bIgnoreAngle))
				continue;
			if(pView->m_iViewType==VIEW_FOOTNAILSLOT&&pLineSlot)
			{
				pPartItem=pView->SonParts.Add(pLineSlot->handle);
				//pPartItem->hSonPart = pLineSlot->handle;
				pView->LoadTagInfo(pPartItem)->pCurPart = pLineSlot;
				pPartItem->cFlag = 0;
			}
			else if(pView->m_iViewType==VIEW_FOOTNAILANGLE&&pLineAngle)
			{
				pPartItem=pView->SonParts.Add(pLineAngle->handle);
				//pPartItem->hSonPart = pLineAngle->handle;
				pView->LoadTagInfo(pPartItem)->pCurPart = pLineAngle;
				pPartItem->cFlag = 0;
			}
		}
		else
		{
			CLDSPart *pFatherPart=BelongModel()->FromPartHandle(pPart->m_hPartWeldParent);
			if(pFatherPart==NULL)
				continue;
			CSlaveSectionView *pSectionView = (CSlaveSectionView*)SonViews.Add(0,CSectionView::CLS_SLAVE_VIEW);
			//CSectionView *pSectionView = SonViews.append();
			pSectionView->m_bLocked=TRUE;
			pSectionView->index=view_index;
			view_index++;
			if(pLineSlot)
			{
				pSectionView->m_iViewType=VIEW_FOOTNAILSLOT;
				strcpy(pSectionView->sName,"脚钉底座视图");
			}
			else
			{	
				pSectionView->m_iViewType=VIEW_FOOTNAILANGLE;
				strcpy(pSectionView->sName,"角钢脚钉视图");
			}
			CParaCS::PARAMETRIC_INFO param=pSectionView->des_cs.GetParamInfo();
			//基准点
			param.desOrg.datum_pos_style=1;
			param.desOrg.des_para.RODEND.hRod=pLineTube->handle;
			param.desOrg.des_para.RODEND.bIncOddEffect=TRUE;
			param.desOrg.des_para.RODEND.direction=0;
			//坐标轴
			param.m_eDatumPlane=CParaCS::DP_ZX;
			param.desAxisZ.norm_style=5;
			param.desAxisZ.hVicePart=pLineTube->handle;
			param.desAxisZ.direction=1;
			//调整端面图与主正视图匹配
			if(pMainView&&pMainView->des_cs.IsDesAxisZ())
				param.desAxisX=pMainView->des_cs.GetParamInfo().desAxisZ;
			else
			{
				param.desAxisX.norm_style=4;
				param.desAxisX.hVicePart=pLineTube->handle;
				param.desAxisX.nearVector.Set(1,0,0);
			}
			pSectionView->des_cs.SetParamInfo(param);
			pSectionView->UpdateUCS(m_pModel,this);

			pSectionView->AddPart(pLineTube->handle,pLineTube);
			pSectionView->AddPart(pPart->handle,pPart);
			pSectionView->InitSlaveSectionView(pMainView,BelongModel());
			hashViewByWeldParentHandle.SetValueAt(pFatherPart->handle,pSectionView);
		}
	}
	return TRUE;
}
//</DEVELOP_PROCESS_MARK>

//<DEVELOP_PROCESS_MARK nameId="CLDSPartGroup::AddCommonRodPartGroupViews">
//提取工作面的展开信息
static int compare_func1(const PARTGROUP_WORKPLANE_STRU &pObj1,const PARTGROUP_WORKPLANE_STRU &pObj2)
{
	if(pObj1.nRayTubeNum>pObj2.nRayTubeNum)
		return 1;
	else if(pObj1.nRayTubeNum==pObj2.nRayTubeNum && pObj1.nPartNum>=pObj1.nPartNum)
		return 1;
	else
		return -1;
}
static void RetrieveWorkPlateSpreadInfo(ATOM_LIST<PARTGROUP_WORKPLANE_STRU>& workplanelist,PARTSET& partset)
{
	PARTGROUP_WORKPLANE_STRU* pWorkPlane=NULL;
	//1、初始化工作面内的优先级判断依据(所属工作面的支管数和板构件数)
	for(pWorkPlane=workplanelist.GetFirst();pWorkPlane;pWorkPlane=workplanelist.GetNext())
	{
		for(CLDSPart* pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
		{
			if(pPart->GetClassTypeId()==CLS_LINETUBE)	
			{
				CLDSLineTube* pTube=(CLDSLineTube*)pPart;
				f3dPoint vec=pTube->End()-pTube->Start();
				normalize(vec);
				double cosa=fabs(vec*pWorkPlane->workPlaneNorm);
				if(cosa<EPS)
					pWorkPlane->nRayTubeNum++;
			}
			else if(pPart->IsPlate())
			{
				double cosa=fabs(pPart->ucs.axis_z*pWorkPlane->workPlaneNorm);
				if(cosa>0.999847695)	//coa1=0.999847695 板在工作面内
					pWorkPlane->nPartNum++;
			}
		}
	}
	//2、对工作面进行优先排序
	ARRAY_LIST<PARTGROUP_WORKPLANE_STRU> workPlateArr;
	workPlateArr.SetSize(0,workplanelist.GetNodeNum());
	for(pWorkPlane=workplanelist.GetFirst();pWorkPlane;pWorkPlane=workplanelist.GetNext())
		workPlateArr.append(*pWorkPlane);
	CQuickSort<PARTGROUP_WORKPLANE_STRU>::QuickSort(workPlateArr.m_pData,workPlateArr.GetSize(),compare_func1);
	workplanelist.Empty();
	for(int i=0;i<workPlateArr.GetSize();i++)
		workplanelist.append(workPlateArr[i]);
	//3、对工作面进行展开处理
	double cos30=0.866025403,max_cos=0.866025403;
	for(PARTGROUP_WORKPLANE_STRU *pMainPlane=workplanelist.GetFirst();pMainPlane;pMainPlane=workplanelist.GetNext())
	{
		PARTGROUP_WORKPLANE_STRU *pSpreadPlane=NULL;
		f3dPoint mainAxisY=-pMainPlane->GetYAxisVec();
		int nPush=workplanelist.push_stack();
		int itemIndex=-1;
		for(pWorkPlane=workplanelist.GetNext();pWorkPlane;pWorkPlane=workplanelist.GetNext())
		{
			f3dPoint spreadAxisY=pWorkPlane->GetYAxisVec();
			double fCos=mainAxisY*spreadAxisY;
			if(fCos>cos30 && fCos>max_cos)
			{
				pSpreadPlane=pWorkPlane;
				itemIndex=workplanelist.GetCurrentIndex();
			}
		}
		if(pSpreadPlane)
		{
			pMainPlane->assistant.m_nStyle=0;	//展开面
			strcpy(pMainPlane->assistant.name,"展开面");
			pMainPlane->assistant.m_xLineStart=pSpreadPlane->csParaInfo.desOrg;
			pMainPlane->assistant.m_xFaceNorm=pSpreadPlane->csParaInfo.desAxisZ;
		}
		if(itemIndex>0)
		{
			workplanelist.DeleteAt(itemIndex);
			workplanelist.Clean();
		}
		workplanelist.pop_stack(nPush);
	}
}
BOOL CLDSPartGroup::AddCommonRodPartGroupViews(CLDSLinePart *pRootLinePart,PARTSET &partset)
{
	if(pRootLinePart==NULL||pRootLinePart->handle!=handle)
		return FALSE;
	f3dPoint axis_vec=pRootLinePart->End()-pRootLinePart->Start();
	normalize(axis_vec);	//单位化杆件长度方向的延伸轴线方向
	if(pRootLinePart->GetClassTypeId()==CLS_LINEANGLE)
		((CLDSLineAngle*)pRootLinePart)->getUCS(pRootLinePart->ucs);
	else if(pRootLinePart->GetClassTypeId()==CLS_LINEFLAT)
		((CLDSLineFlat*)pRootLinePart)->BuildUCS();
	else if(pRootLinePart->GetClassTypeId()==CLS_LINESLOT)
		((CLDSLineSlot*)pRootLinePart)->BuildUCS();
	else if(pRootLinePart->GetClassTypeId()==CLS_LINETUBE)
		((CLDSLineTube*)pRootLinePart)->BuildUCS();

	//添加普通组焊件的默认视图
	//1、提取组焊图工作面
	PARTGROUP_WORKPLANE_STRU *pWorkPlane=NULL;
	ATOM_LIST<PARTGROUP_WORKPLANE_STRU>workplanelist;
	for(CLDSPart *pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
	{	//应该去掉部分不需要的正视图 主要是由与钢管不垂直也不平行的一些钢板所形成的一些正视图
		//如某些跨越钢管连板，环向板，环向肋板，异性法兰等
		PARTGROUP_WORKPLANE_STRU workplane;
		workplane.csParaInfo.desOrg.datum_pos_style=1;	//杆件端点为基准
		workplane.csParaInfo.desOrg.des_para.hPart=pRootLinePart->handle;
		workplane.csParaInfo.desOrg.des_para.RODEND.bIncOddEffect=TRUE;
		workplane.csParaInfo.desOrg.des_para.RODEND.direction=0;
		workplane.csParaInfo.desAxisX.norm_style=5;
		workplane.csParaInfo.desAxisX.hVicePart=pRootLinePart->handle;
		workplane.csParaInfo.desAxisX.direction=0;
		if(pPart->GetClassTypeId()==CLS_PARAMPLATE || pPart->GetClassTypeId()==CLS_PLATE)
		{	//提取由钢管沿向钢板展开面形成的视图
			if(pPart->GetClassTypeId()==CLS_PARAMPLATE&&
				(((CLDSParamPlate*)pPart)->m_iParamType==TYPE_ELBOWPLATE||
				((CLDSParamPlate*)pPart)->m_iParamType==TYPE_RIBPLATE))
				continue;	//法兰肘板不单独生成组焊子视图
			if(pRootLinePart->GetClassTypeId()==CLS_LINETUBE&&fabs(pPart->ucs.axis_z*axis_vec)>EPS)	//TODO: 是不是应该提高精度为EPS? wjh-2013.12.07
				continue;	//跳过非钢管沿向钢板（即保留钢管沿向钢板）
			workplane.csParaInfo.m_eDatumPlane=CParaCS::DP_XZ;
			workplane.csParaInfo.desAxisZ.norm_style=3;	//构件工作法线
			workplane.csParaInfo.desAxisZ.hVicePart=pPart->handle;
			f3dPoint verfiy_norm=AdjustPlateWorkPlaneNorm(pPart->ucs.axis_z,pPart->layer(2));
			if(pPart->ucs.axis_z*verfiy_norm<0)
			{
				workplane.csParaInfo.desAxisZ.direction=0;	//朝内
				workplane.workPlaneNorm =-pPart->ucs.axis_z;
			}
			else
			{
				workplane.csParaInfo.desAxisZ.direction=1;	//朝外
				workplane.workPlaneNorm = pPart->ucs.axis_z;
			}
		}
		else if(pPart->GetClassTypeId()==CLS_LINETUBE)	
		{	//提取由其它焊接支管形成的交叉面视图
			CLDSLineTube *pBranchTube=(CLDSLineTube*)pPart;
			f3dPoint branch_tube_line_vec=pBranchTube->End()-pBranchTube->Start();
			workplane.workPlaneNorm=branch_tube_line_vec^axis_vec;
			normalize(workplane.workPlaneNorm);
			workplane.csParaInfo.m_eDatumPlane=CParaCS::DP_XZ;
			workplane.csParaInfo.desAxisZ.norm_style=2;	//杆件交叉面法线
			workplane.csParaInfo.desAxisZ.hVicePart=pRootLinePart->handle;
			workplane.csParaInfo.desAxisZ.hCrossPart=pBranchTube->handle;
			if(pBranchTube->layer(2)=='Q')
				workplane.csParaInfo.desAxisZ.nearVector.Set(0, 1,0);
			else if(pBranchTube->layer(2)=='H')
				workplane.csParaInfo.desAxisZ.nearVector.Set(0,-1,0);
			else if(pBranchTube->layer(2)=='Z')
				workplane.csParaInfo.desAxisZ.nearVector.Set(-1,0,0);
			else if(pBranchTube->layer(2)=='Y')
				workplane.csParaInfo.desAxisZ.nearVector.Set( 1,0,0);
		}
		else
		{
			logerr.Log("目前不支持非钢管形式的焊接分支杆件0X%X！",pPart->handle);
			continue;
		}

		for(pWorkPlane=workplanelist.GetFirst();pWorkPlane;pWorkPlane=workplanelist.GetNext())
		{	//法线方向接近的工作平面没必要重复添加，现将误差范围调整为EPS_COS2
			double dd=fabs(pWorkPlane->workPlaneNorm*workplane.workPlaneNorm);
			if(dd<0.999847695)	//COS(1°)=0.999847695, 不严格执行共面是为了避免分支杆件工作面与板面有时不严格共面(但在工程误差范围内)的情况。
				continue;
			if(dd<EPS_COS)
			{
				char sWorkNormInfo[100];
				if(pPart->IsPlate())
					sprintf(sWorkNormInfo,"0X%X钢板的工作面法线",pPart->handle);
				else
					sprintf(sWorkNormInfo,"由0X%X构件与基准杆件0X%X形成的组焊工作平面",pPart->handle,pRootLinePart->handle);
				double diff=ACOS(dd)*DEGTORAD_COEF;
				if(fabs(diff)>0.05)
					logerr.Log("%s组焊件'%s'中，%s与其归属工作平面不不严格共面{%.1f°}!",sRootPartNo,pWorkPlane->sName,sWorkNormInfo,diff);
			}
			break;	//已存在此工作面法线方向
		}
		if(pWorkPlane==NULL)	//新的工作面法线方向
		{
			workplane.workPlaneOrg=pRootLinePart->Start();
			workplane.pDatumPart=pPart;
			//尽量保证描述前面构件或后面构件的视图作为主视图 wht 10-08-15
			/*PARTGROUP_WORKPLANE_STRU *pFirstWorkPlane=workplanelist.GetFirst();
			char cFirstType,cCurType;
			if(pFirstWorkPlane&&pFirstWorkPlane->pDatumPart)
				cFirstType=toupper(pFirstWorkPlane->pDatumPart->layer(2));
			cCurType=toupper(pPart->layer(2));
			if(workplanelist.GetNodeNum()==0)
				strcpy(workplane.sName,"主视图");
			else
				sprintf(workplane.sName,"正视图%d",workplanelist.GetNodeNum());
			if((cFirstType!='Q'&&cCurType=='Q')||(cFirstType!='Q'&&cFirstType!='H'&&cCurType=='H'))
				workplanelist.insert(workplane);
			else
				workplanelist.append(workplane);*/
			workplanelist.append(workplane);
		}
	}
	//2、对近似共面的工作面进行展开处理
	RetrieveWorkPlateSpreadInfo(workplanelist,partset);
	//3、为每个工作面添加一个对应的视图
	int view_index=1,perp_view_hits=1;
	CSectionView *pMainView=NULL;	//记录主视图，调整端面视图与主视图一致时使用 wht 12-09-05
	//cos(1°)=0.99985，以1°为计算误差范围  
	const double cosa1=0.99985;
	for(pWorkPlane=workplanelist.GetFirst();pWorkPlane;pWorkPlane=workplanelist.GetNext())
	{	//基准构件为钢管时不生成包含组焊件所有构件的端面图，构件太多标注会比较乱且无实际意义。 wht 09-11-24
		//if(pRootLinePart->GetClassTypeId()==CLS_LINETUBE&&fabs(pWorkPlane->workPlaneNorm*axis_vec)>cosa1)	//钢管端面视图
		//	continue;		//钢管为基准构件的组焊图，工作面中不可能包括视图方向与钢管轴向平行的视图 wht 13-12-12
		//CSectionView *pSectionView = SonViews.append();
		CSectionView *pSectionView = SonViews.Add(0,CSectionView::CLS_BASIC_VIEW);
		pSectionView->index=view_index++;	//视图索引
		//杆件垂向投影视图
		if(SonViews.GetNodeNum()==1)	//将第一个正视图作为主正视图 端面图应与主正视图匹配
		{
			sprintf(pSectionView->sName,"主视图");
			//strcpy(pSectionView->sName,pWorkPlane->sName);
			pSectionView->m_iViewType=VIEW_MAIN;	
			pMainView=pSectionView;	//记录主视图
		}
		else
		{
			//为了在之前防错报警中准确提示视图名称，故提前设定名称
			sprintf(pSectionView->sName,"正视图%d",perp_view_hits);
			//strcpy(pSectionView->sName,pWorkPlane->sName);
			pSectionView->m_iViewType=VIEW_FRONT;
			perp_view_hits++;
		}
		pSectionView->des_cs.SetParamInfo(pWorkPlane->csParaInfo);
		pSectionView->UpdateUCS(m_pModel,this);
		//
		pSectionView->AddPart(pRootLinePart->handle,pRootLinePart);
		if(pWorkPlane->assistant.m_xFaceNorm.vector.IsZero())
		{
			for(CLDSPart *pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
				pSectionView->AddPart(pPart->handle,pPart);
		}
		else
		{
			//添加视图展开面及构件
			CDrawingAssistant* pAssist=pSectionView->hashAssistPlanes.Add(0);
			pAssist->m_nStyle=pWorkPlane->assistant.m_nStyle;
			pAssist->m_xLineStart=pWorkPlane->assistant.m_xLineStart;
			pAssist->m_xFaceNorm=pWorkPlane->assistant.m_xFaceNorm;
			strcpy(pAssist->name,pWorkPlane->assistant.name);
			pAssist->m_xFaceNorm.UpdateVector(m_pModel);
			f3dPoint spreadNorm=pAssist->m_xFaceNorm.vector;
			CSectionView::PART_ITEM* pItem=NULL;
			for(CLDSPart *pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
			{
				double fCosMain=0,fCosSpread=0;
				if(pPart->IsLinePart())
				{
					CLDSLinePart* pLinePart=(CLDSLinePart*)pPart;
					f3dPoint vec=pLinePart->End()-pLinePart->Start();
					normalize(vec);
					fCosSpread=fabs(vec*spreadNorm);
					fCosMain=fabs(vec*pSectionView->ucs.axis_z);
								
				}
				else if(pPart->IsPlate())
				{
					fCosSpread=fabs(pPart->ucs.axis_z*spreadNorm);
					fCosMain=fabs(pPart->ucs.axis_z*pSectionView->ucs.axis_z);
				}
				if(fCosSpread<fCosMain)
				{
					if(fCosSpread<EPS2)
					{
						pItem=pSectionView->AddPart(pPart->handle);
						pItem->iResidePlaneNo=pAssist->iNo;
						pItem->cFlag='X';	//杆件正视图/板的截面图
					}
					else if(fCosMain>EPS_COS2)
					{
						pItem=pSectionView->AddPart(pPart->handle);
						pItem->cFlag='Z';	//杆件截面图/板的正视图
					}
				}
				else if(fCosMain<fCosSpread)
				{
					if(fCosMain<EPS2)
					{
						pItem=pSectionView->AddPart(pPart->handle);
						pItem->cFlag='X';	//杆件正视图/板的截面图
					}
					else if(fCosSpread>EPS_COS)
					{
						pItem=pSectionView->AddPart(pPart->handle);
						pItem->iResidePlaneNo=pAssist->iNo;
						pItem->cFlag='Z';	//杆件截面图/板的正视图
					}
				}		
			}
		}
	}
	//3、基准构件为钢管时需要添加钢管端面视图
	if(pRootLinePart->GetClassTypeId()==CLS_LINETUBE)
	{
		CLDSLineTube *pLineTube=(CLDSLineTube*)pRootLinePart;
		pLineTube->BuildUCS();
		if(SonViews.GetNodeNum()<=0)
		{	//3.1 无主视图(如钢管两端均为法兰且钢管上无连接板的情况)
			//CSectionView *pSectionView = SonViews.append();
			CSectionView *pSectionView = SonViews.Add(0,CSectionView::CLS_BASIC_VIEW);
			pSectionView->index=view_index++;	//视图索引
			//
			CParaCS::PARAMETRIC_INFO param=pSectionView->des_cs.GetParamInfo();
			//基准点
			param.desOrg.datum_pos_style=1;
			param.desOrg.des_para.RODEND.hRod=pLineTube->handle;
			param.desOrg.des_para.RODEND.bIncOddEffect=TRUE;
			param.desOrg.des_para.RODEND.direction=0;
			//坐标轴
			param.m_eDatumPlane=CParaCS::DP_XY;
			param.desAxisX.norm_style=5;
			param.desAxisX.hVicePart=pLineTube->handle;
			param.desAxisX.direction=0;
		
			param.desAxisY.norm_style=4;
			param.desAxisY.hVicePart=pLineTube->handle;
			param.desAxisY.nearVector.Set(1,0,0);
			pSectionView->des_cs.SetParamInfo(param);
			pSectionView->UpdateUCS(m_pModel,this);
			//
			sprintf(pSectionView->sName,"主视图");
			pSectionView->m_iViewType=VIEW_MAIN;
			pMainView=pSectionView;	//记录主视图

			pSectionView->AddPart(pRootLinePart->handle,pRootLinePart);
			for(CLDSPart *pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
				pSectionView->AddPart(pPart->handle,pPart);
		}
		//预留始端视图索引位置
		int iStartView=-1;
		CLDSParamPlate *pStartPlate=(CLDSParamPlate*)BelongModel()->FromPartHandle(pLineTube->m_tJointStart.hLinkObj,CLS_PARAMPLATE);
		if(pStartPlate)
			iStartView=view_index++;
		//3.2 添加钢管中间节点对应的端面视图
		AddLineTubeMiddleNodeEndView(pLineTube,pMainView,partset,view_index);
		//3.3 添加钢管端头视图(包括法兰视图、插板视图、平面切割视图)
		AddLineTubeEndLjView(pLineTube,pMainView,partset,iStartView,view_index);
		//3.4 为组焊件中脚钉底座添加端面图
		AddFootNailView(pLineTube,pMainView,partset,view_index);
		//3.5 支管端面图
		//TODO: 干什么用的？
		/*
		TUBESET tubeSet;	//支管集合
		for(pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
		{
			if(pPart->GetClassTypeId()==CLS_LINETUBE&&pPart->handle!=pRootLinePart->handle)
				tubeSet.append((CLDSLineTube*)pPart);
		}
		if(tubeSet.GetNodeNum()>0)
		{
			hashViewByWeldParentHandle.Empty();
			hashViewByWeldParentHandle.CreateHashTable(tubeSet.GetNodeNum());
			CLDSLineTube *pBranchTube=NULL;
			f3dLine datum_line(pLineTube->pStart->Position(true),pLineTube->pEnd->Position(true));
			for(pBranchTube=tubeSet.GetFirst();pBranchTube;pBranchTube=tubeSet.GetNext())
			{
				CLDSNode *pBaseNode=NULL;
				if(datum_line.PtInLine(pBranchTube->pStart->Position(true))>0)
					pBaseNode=pBranchTube->pStart;
				else if(datum_line.PtInLine(pBranchTube->pEnd->Position(true))>0)
					pBaseNode=pBranchTube->pEnd;
				else
					continue;
				if(pBaseNode==NULL)
					continue;
				CSectionView *pSectionView=NULL;
				if(hashViewByWeldParentHandle.GetValueAt(pBaseNode->handle,pSectionView))
				{
					CSectionView::PART_ITEM *pPartItem=pSectionView->SonParts.append();
					pPartItem->hSonPart = pBranchTube->handle;
					pPartItem->pCurPart = pBranchTube;
					pPartItem->cFlag = 0;
				}	
				else
				{
					CSectionView *pSectionView = SonViews.append();
					pSectionView->m_bLocked=TRUE;
					pSectionView->index=view_index;
					view_index++;
					pSectionView->m_iViewType=VIEW_BRACHTUBE;
					strcpy(pSectionView->sName,"支管视图");
					CParaCS::PARAMETRIC_INFO param=pSectionView->des_cs.GetParamInfo();
					//基准点
					param.desOrg.datum_pos_style=2;	//杆件上节点为基准
					param.desOrg.des_para.LINEPARTNODE.hNode=pBaseNode->handle;
					param.desOrg.des_para.LINEPARTNODE.hLinePart=pRootLinePart->handle;
					//坐标轴
					param.m_eDatumPlane=CParaCS::DP_ZX;
					param.desAxisZ.norm_style=5;
					param.desAxisZ.hVicePart=pLineTube->handle;
					param.desAxisZ.direction=1;
					//调整端面图与主正视图匹配
					if(pMainView&&pMainView->des_cs.IsDesAxisZ())
						param.desAxisX=pMainView->des_cs.GetParamInfo().desAxisZ;
					else
					{
						param.desAxisX.norm_style=4;
						param.desAxisX.hVicePart=pLineTube->handle;
						param.desAxisX.nearVector.Set(1,0,0);
					}
					pSectionView->des_cs.SetParamInfo(param);
					pSectionView->UpdateUCS(m_pModel,this);
					
					pSectionView->AddPart(pRootLinePart->handle,pRootLinePart);
					pSectionView->AddPart(pBranchTube->handle,pBranchTube);
					hashViewByWeldParentHandle.SetValueAt(pBaseNode->handle,pSectionView);
				}
			}
		}*/
		//for(CSectionView *pSectionView=SonViews.GetFirst();pSectionView;pSectionView=SonViews.GetNext())
		//	pSectionView->AddDefaultAngulars(pRootLinePart,&Ta);//添加默认的角度标注线
	}
	return TRUE;
}
//</DEVELOP_PROCESS_MARK>

//4.添加基准构件为钢板的组焊件视图
BOOL CLDSPartGroup::AddPlatePartGroupViews(CLDSPlate *pRootPlate,PARTSET &partset)
{
	if(pRootPlate==NULL||pRootPlate->handle!=handle)
		return FALSE;
	if(m_bFootPartGroup)
	{	//添加塔脚板默认视图
		CLDSLineAngle *pDatumLineAngle1=NULL,*pDatumLineAngle2=NULL;
		pDatumLineAngle1=(CLDSLineAngle*)m_pModel->FromPartHandle(pRootPlate->designInfo.m_hBasePart,CLS_LINEANGLE,CLS_GROUPLINEANGLE);
		CDesignLjPartPara *pLjPartPara=NULL;
		for(pLjPartPara=pRootPlate->designInfo.partList.GetFirst();pLjPartPara;pLjPartPara=pRootPlate->designInfo.partList.GetNext())
		{
			if(pLjPartPara->hPart==pRootPlate->designInfo.m_hBasePart)
				continue;
			CLDSLineAngle *pLineAngle=(CLDSLineAngle*)m_pModel->FromPartHandle(pRootPlate->designInfo.m_hBasePart,CLS_LINEANGLE,CLS_GROUPLINEANGLE);
			if(pDatumLineAngle1==NULL)
				pDatumLineAngle1=pLineAngle;
			else if(pDatumLineAngle2==NULL)
				pDatumLineAngle2=pLineAngle;
		}
		f3dLine line;
		f3dArcLine arcline;
		if(pDatumLineAngle1==NULL&&pDatumLineAngle2==NULL)
			return FALSE;	//无基准杆件
		for(int i=0;i<6;i++)
		{
			if(i==5&&(pDatumLineAngle1==NULL||pDatumLineAngle2==NULL))
				continue;	//非牛蹄板无需添加仰视图
			//CSectionView *pSectionView = SonViews.append();
			CSectionView *pSectionView = SonViews.Add(0,CSectionView::CLS_BASIC_VIEW);
			UCS_STRU tm_ucs = pRootPlate->ucs;
			if(i==0)	
			{	//前面视图
				tm_ucs.axis_x.Set(1,0,0);
				tm_ucs.axis_y.Set(0,0,-1);
				tm_ucs.axis_z.Set(0,1,0);
				sprintf(pSectionView->sName,"%s","前面视图");
			}
			else if(i==1)
			{	//右面视图
				tm_ucs.axis_x.Set(0,-1,0);
				tm_ucs.axis_y.Set(0,0,-1);
				tm_ucs.axis_z.Set(1,0,0);
				sprintf(pSectionView->sName,"%s","右面视图");
			}
			else if(i==2)
			{	//后面视图
				tm_ucs.axis_x.Set(-1,0,0);
				tm_ucs.axis_y.Set(0,0,-1);
				tm_ucs.axis_z.Set(0,-1,0);
				sprintf(pSectionView->sName,"%s","后面视图");
			}
			else if(i==3)
			{	//左面视图
				tm_ucs.axis_x.Set(0,1,0);
				tm_ucs.axis_y.Set(0,0,-1);
				tm_ucs.axis_z.Set(-1,0,0);
				sprintf(pSectionView->sName,"%s","左面视图");
			}
			else if(i==4)
			{	//俯视图
				tm_ucs=pRootPlate->ucs;
				sprintf(pSectionView->sName,"%s","俯视图");
			}
			else if(i==5)
			{	//仰视图
				tm_ucs=pRootPlate->ucs;
				//仰视图坐标系需要将坐标原点定位在底板顶面  wht 10-01-14
				tm_ucs.origin=pRootPlate->ucs.origin+pRootPlate->ucs.axis_z*pRootPlate->GetThick();
				tm_ucs.axis_z*=-1.0;
				tm_ucs.axis_y*=-1.0;
				sprintf(pSectionView->sName,"%s","仰视图");
			}

			if((fabs(tm_ucs.axis_x.y)<EPS2||fabs(tm_ucs.axis_x.x)<EPS2)&&i<4)	
			{	//正/侧面图
				tm_ucs.axis_z.z=0;
				normalize(tm_ucs.axis_z);
				tm_ucs.axis_y=tm_ucs.axis_z^tm_ucs.axis_x;
				tm_ucs.axis_x=tm_ucs.axis_y^tm_ucs.axis_z;
				normalize(tm_ucs.axis_x);
				normalize(tm_ucs.axis_y);
			}
			pSectionView->ucs=tm_ucs;
			//坐标系设置参数
			CParaCS::PARAMETRIC_INFO param=pSectionView->des_cs.GetParamInfo();
			param.desOrg.datum_pos_style=0;
			param.desOrg.datum_pos=tm_ucs.origin;
			param.m_eDatumPlane=CParaCS::DP_XY;
			param.desAxisX.norm_style=0;
			param.desAxisX.vector=tm_ucs.axis_x;
			param.desAxisY.norm_style=0;
			param.desAxisY.vector=tm_ucs.axis_y;
			param.desAxisZ.norm_style=0;
			param.desAxisZ.vector=tm_ucs.axis_z;
			pSectionView->des_cs.SetParamInfo(param);
			//
			pSectionView->AddPart(pRootPlate->handle,pRootPlate);
			for(CLDSPart *pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
			{
				if(i>3&&pDatumLineAngle1&&pDatumLineAngle2&&pPart->GetClassTypeId()==CLS_PLATE)
				{	//仰/俯视图 仅显示Z轴正方向的钢板
					PROFILE_VERTEX *pVertex=NULL;
					CLDSPlate *pTmpPlate=(CLDSPlate*)pPart;
					for(pVertex=pTmpPlate->vertex_list.GetFirst();pVertex;pVertex=pTmpPlate->vertex_list.GetNext())
					{
						f3dPoint vertex=pVertex->vertex;
						coord_trans(vertex,pTmpPlate->ucs,TRUE);
						coord_trans(vertex,pSectionView->ucs,FALSE);
						if(vertex.z<0)
							break;
					}
					if(pVertex)
						continue;
				}
				pSectionView->AddPart(pPart->handle,pPart);
			}
			//pSectionView->AddDefaultLocatePoints(pRootPlate,SuperiorTower());	//添加默认的标定点
			//pSectionView->AddDefaultCheckLines(pRootPlate,SuperiorTower());	//添加默认的检测线
			//pSectionView->AddDefaultAngulars(pRootPlate,SuperiorTower());		//添加默认的角度标注线
		}
	}
	else
	{
		CLDSGroupLineAngle *pGroupLineAngle=NULL;
		pGroupLineAngle=(CLDSGroupLineAngle*)BelongModel()->FromPartHandle(pRootPlate->designInfo.m_hBasePart,CLS_GROUPLINEANGLE);
		//CSectionView *pSectionView = SonViews.append();
		CSectionView *pSectionView = SonViews.Add(0,CSectionView::CLS_BASIC_VIEW);
		sprintf(pSectionView->sName,"%s","正视图");

		CParaCS::PARAMETRIC_INFO param=pSectionView->des_cs.GetParamInfo();
		param.desOrg.datum_pos_style=9;
		param.desOrg.des_para.hPart=pRootPlate->handle;
		param.desOrg.datum_pos.Set();
		//
		param.m_eDatumPlane=CParaCS::DP_XY;
		param.desAxisX.norm_style=4;
		param.desAxisX.hVicePart=pRootPlate->handle;
		param.desAxisX.nearVector.Set(1,0,0);
		param.desAxisY.norm_style=4;
		param.desAxisY.hVicePart=pRootPlate->handle;
		param.desAxisY.nearVector.Set(0,1,0);
		param.desAxisZ.norm_style=4;
		param.desAxisZ.hVicePart=pRootPlate->handle;
		param.desAxisZ.nearVector.Set(0,0,1);
		pSectionView->des_cs.SetParamInfo(param);
		pSectionView->UpdateUCS(m_pModel,this);

		pSectionView->AddPart(pRootPlate->handle,pRootPlate);
		for(CLDSPart *pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
			pSectionView->AddPart(pPart->handle,pPart);
		//pSectionView->AddDefaultLocatePoints(pRootPlate,SuperiorTower());	//添加默认的标定点
		//pSectionView->AddDefaultCheckLines(pRootPlate,SuperiorTower());	//添加默认的检测线
		//pSectionView->AddDefaultAngulars(pRootPlate,SuperiorTower());		//添加默认的角度标注线
		if(pGroupLineAngle)
		{	//组合角钢填板 添加正视图与截面图	
			//正视图 保证与结构图中的摆放方向大致相同
			double fFlag=1.0;
			f3dPoint line_vec=pGroupLineAngle->End()-pGroupLineAngle->Start();
			normalize(line_vec);
			if(line_vec*pSectionView->ucs.axis_y>0)
			{
				pSectionView->ucs.axis_x*=-1.0;
				pSectionView->ucs.axis_y*=-1.0;
				fFlag=-1.0;
			}
			UCS_STRU ucs=pSectionView->ucs;	//记录调整后正视图的坐标系
			//截面图 需标注钢板之间的夹角 若子钢板有螺栓则标注第一排螺栓到基准钢板的距离 否则标注钢板边缘到基准钢板的距离
			//pSectionView = SonViews.append();
			pSectionView = SonViews.Add(0,CSectionView::CLS_BASIC_VIEW);
			sprintf(pSectionView->sName,"%s","端面图");
			//
			param=pSectionView->des_cs.GetParamInfo();
			param.desOrg.datum_pos_style=9;
			param.desOrg.des_para.hPart=pRootPlate->handle;
			param.desOrg.datum_pos.Set();
			//
			param.m_eDatumPlane=CParaCS::DP_ZY;
			param.desAxisZ.norm_style=4;
			param.desAxisZ.hVicePart=pRootPlate->handle;
			param.desAxisZ.nearVector.Set(0,1*fFlag,0);
			param.desAxisY.norm_style=4;
			param.desAxisY.hVicePart=pRootPlate->handle;
			param.desAxisY.nearVector.Set(0,0,-1*fFlag);
			pSectionView->des_cs.SetParamInfo(param);
			pSectionView->UpdateUCS(m_pModel,this);
			
			pSectionView->AddPart(pRootPlate->handle,pRootPlate);
			for(pPart=partset.GetFirst();pPart;pPart=partset.GetNext())
				pSectionView->AddPart(pPart->handle,pPart);
			//pSectionView->AddDefaultLocatePoints(pDatumPart,SuperiorTower());	//添加默认的标定点
			//pSectionView->AddDefaultCheckLines(pDatumPart,SuperiorTower());	//添加默认的检测线
			//pSectionView->AddDefaultAngulars(pDatumPart,SuperiorTower());		//添加默认的角度标注线
		}
	}
	return TRUE;
}
//
BOOL CLDSPartGroup::AddDefaultAttachViews()
{
	int i=0;
	PARTSET partset;
	CSuperSmartPtr<CLDSPart>pDatumPart=BelongModel()->FromPartHandle(handle);
	if(pDatumPart.IsNULL())
		return FALSE;
	SmartIdentifyGroupType();
	BelongModel()->GetPartGroupPartSet(handle,partset);
	if(pDatumPart->IsLinePart())
	{
		if(pDatumPart->GetClassTypeId()==CLS_LINEANGLE)
			pDatumPart.LineAnglePointer()->getUCS(pDatumPart->ucs);
		else if(pDatumPart->GetClassTypeId()==CLS_LINEFLAT)
			pDatumPart.LineFlatPointer()->BuildUCS();
		else if(pDatumPart->GetClassTypeId()==CLS_LINESLOT)
			pDatumPart.LineSlotPointer()->BuildUCS();
		else if(pDatumPart->GetClassTypeId()==CLS_LINETUBE)
			pDatumPart.LineTubePointer()->BuildUCS();
		//添加特殊部位组焊件视图
		BOOL bRetCode=FALSE;
		if(!bRetCode&&pDatumPart->GetClassTypeId()==CLS_LINETUBE)	//对接相贯钢管视图
			bRetCode=AddJointTubeViews(pDatumPart.LineTubePointer(),partset);
		if(!bRetCode&&pDatumPart->GetClassTypeId()==CLS_LINETUBE)	//四根支管相贯与主管的K节点类组焊件
			bRetCode=AddKNodeTransectViews(pDatumPart.LineTubePointer(),partset);
		if(!bRetCode)	//普通杆件为基准的组焊件
			bRetCode=AddCommonRodPartGroupViews(pDatumPart.LinePartPointer(),partset);
		return bRetCode;
	}
#ifdef __COMPLEX_PART_INC_
	else if(pDatumPart->GetClassTypeId()==CLS_SPHERE&&m_iPartGroupType==GROUP_SPHERE)
	{
		CSpherePartGroup extrator(this);
		return extrator.AddSpherePartGroupViews(pDatumPart.SpherePointer(),partset);
	}
#endif
	else if(pDatumPart->GetClassTypeId()==CLS_PLATE)
		AddPlatePartGroupViews(pDatumPart.PlatePointer(),partset);
	else
		return FALSE;
	return TRUE;
}
int CLDSPartGroup::SmartIdentifyGroupType()	//智能识别组合类型
{
	CSuperSmartPtr<CLDSPart>pDatumPart=BelongModel()->FromPartHandle(handle);
	if(pDatumPart.IsHasPtr()&&pDatumPart->GetClassTypeId()==CLS_SPHERE)
		m_iPartGroupType=GROUP_SPHERE;
	return m_iPartGroupType;
}
//prefer为优先推荐的键值类型，如'A1',则生成Ax系列的空闲剖视符号
KEY2C CLDSPartGroup::GetIdleSectSymbol(){return GetIdleSectSymbol(KEY2C());}
KEY2C CLDSPartGroup::GetIdleSectSymbol(KEY2C prefer)
{
	CHashList<KEY2C> hashKeys;
	BOOL pushed=SonViews.push_stack();
	for(CSectionView* pView=SonViews.GetFirst();pView;pView=SonViews.GetNext())
	{
		if(!pView->IsSlaveView())
			continue;
		KEY2C symbolkey(pView->symbol);
		hashKeys.SetValue(symbolkey,symbolkey);
	}
	SonViews.pop_stack(pushed);
	if(prefer.wItem!=0&&hashKeys.GetValue(prefer)==NULL)
		return prefer;
	else
	{
		char symbol[3]="";
		int prefer_len=max(1,strlen(prefer.Label()));
		KEY2C maxkey("@");
		for(KEY2C *pKey=hashKeys.GetFirst();pKey;pKey=hashKeys.GetNext())
		{
			if(prefer_len==1)
			{
				symbol[0]=*pKey->Label()+1;
				if(hashKeys.GetValue(KEY2C(symbol))==NULL)
					return KEY2C(symbol);
			}
			else //if(prefer_len==2)
			{
				strncpy(symbol,pKey->Label(),2);
				symbol[1]+=1;
				if(hashKeys.GetValue(KEY2C(symbol))==NULL)
					return KEY2C(symbol);
			}
			if(maxkey.wItem<pKey->wItem)
				maxkey.wItem=pKey->wItem;
		}
		if(prefer_len==1)
			maxkey.wItem+=1;
		else
			*(maxkey.Label()+1)+=1;
		return maxkey; 
	}
}

BOOL CLDSPartGroup::GetDesignItemValue(WORD wKey, long *phPart,CHashTable<DESIGN_PLATE_ITEM*>*pTbl/*=NULL*/)
{
	DESIGN_PLATE_ITEM *pItem=NULL;
	if(pTbl)
		pTbl->GetValueAt(wKey,pItem);
	else
	{
		for(pItem=designItemList.GetFirst();pItem;pItem=designItemList.GetNext())
		{
			if(pItem->key.wItem==wKey)
				break;
		}
	}
	if(pItem)
	{
		if(pItem->dataType==0)
		{
			if(phPart)
				*phPart = ftoi(pItem->value.fValue);
			return TRUE;
		}
		else if(pItem->dataType==1)
		{
			if(phPart)
				*phPart = pItem->value.hPart;
			return TRUE;
		}
	}
	return FALSE;
}
char* CLDSPartGroup::GetDesignItemNotes(WORD wKey)
{
	for(DESIGN_PLATE_ITEM *pItem=designItemList.GetFirst();pItem;pItem=designItemList.GetNext())
	{
		if(pItem->key.wItem==wKey)
			return pItem->sNotes;
	}
	return 0;
}
DESIGN_PLATE_ITEM *CLDSPartGroup::GetDesignItem(WORD wKey)
{
	for(DESIGN_PLATE_ITEM *pItem=designItemList.GetFirst();pItem;pItem=designItemList.GetNext())
	{
		if(pItem->key.wItem==wKey)
			return pItem;	
	}
	return NULL;
}
BOOL CLDSPartGroup::IsHasDesignItemValue(WORD wKey)
{
	for(DESIGN_PLATE_ITEM *pItem=designItemList.GetFirst();pItem;pItem=designItemList.GetNext())
	{
		if(pItem->key.wItem==wKey)
			return TRUE;
	}
	return FALSE;
}
BOOL CLDSPartGroup::DeleteDesignItem(WORD wKey)
{
	for(DESIGN_PLATE_ITEM *pItem=designItemList.GetFirst();pItem;pItem=designItemList.GetNext())
	{
		if(pItem->key.wItem==wKey)
		{
			designItemList.DeleteCursor();
			return TRUE;
		}
	}
	return FALSE;
}
//BOOL CLDSPartGroup::SetDesignItemValue(WORD wKey,long lValue,char *sNotes=NULL,BOOL bModify=FALSE);

#endif